{"version":3,"sources":["leaflet.pm.js","Drag.js","Overlap.js","Snapping.js","L.PM.js","L.PM.Map.js","L.PM.Draw.js","L.PM.Edit.js","Edit/L.PM.Edit.Circle.js","Edit/L.PM.Edit.LayerGroup.js","Edit/L.PM.Edit.Line.js","Edit/L.PM.Edit.Marker.js","Edit/L.PM.Edit.Poly.js","Draw/L.PM.Draw.Circle.js","Draw/L.PM.Draw.Line.js","Draw/L.PM.Draw.Marker.js","Draw/L.PM.Draw.Poly.js","Toolbar/L.Controls.js","Toolbar/L.PM.Toolbar.js"],"names":["DragMixin","_initDraggableLayer","this","_tempDragCoord","el","_layer","_path","L","DomUtil","addClass","on","_dragMixinOnMouseDown","_dragMixinOnMouseUp","_this","_map","dragging","enable","off","_dragMixinOnMouseMove","_dragging","_initMarkers","window","setTimeout","removeClass","fire","_fireEdit","e","bringToFront","disable","_markerGroup","clearLayers","_onLayerDrag","latlng","deltaLatLng","lat","lng","coords","Polygon","_latlngs","newLatLngs","map","currentLatLng","c","setLatLngs","redraw","OverlapMixin","_applyPossibleCoordsChanges","_tempPolygon","latlngs","getLayers","getLatLngs","_poly","_drawTemporaryPolygon","geoJson","setStyle","opacity","fillOpacity","addTo","bringToBack","_handleOverlap","mainPoly","layers","_layerGroup","changed","resultingGeoJson","toGeoJSON","filter","layer","Object","is","intersect","turf","console","warn","difference","geometry","type","remove","SnapMixin","_initSnappableMarkers","options","snapDistance","_markers","forEach","marker","_handleSnapping","_cleanupSnapping","_unsnap","_snapLatLng","_snapList","debugIndicatorLines","line","originalEvent","altKey","undefined","_createSnapList","length","target","closestLayer","_calcClosestLayer","getLatLng","isMarker","Marker","CircleMarker","snapLatLng","_checkPrioritiySnapping","minDistance","eventInfo","segment","layerInteractedWith","distance","setLatLng","_snapped","A","B","C","distanceAC","_getDistance","distanceBC","closestVertexLatLng","shortestDistance","priorityDistance","snapLatlng","assign","_this2","eachLayer","Polyline","push","debugLine","polyline","color","_latlng","_pmTempLayer","_otherSnapLayers","concat","_this3","index","results","_calcLayerDistances","_this4","isPolygon","isPolyline","P","closestSegment","coord","nextIndex","_getDistanceToSegment","_getClosestPointOnSegment","latlngA","latlngB","maxzoom","getMaxZoom","Infinity","getZoom","project","closest","LineUtil","closestPointOnSegment","unproject","latLngToLayerPoint","pointToSegmentDistance","distanceTo","PM","version","initialize","addInitHooks","initLayerGroup","pm","Edit","LayerGroup","initMarker","initPolygon","Poly","initPolyline","Line","initCircle","Circle","initMap","Map","addInitHook","Class","extend","Draw","Toolbar","addControls","removeControls","toggleControls","controlsVisible","isVisible","enableDraw","shape","arguments","disableDraw","setPathOptions","removeLayer","_layers","toggleGlobalRemovalMode","globalRemovalEnabled","_globalRemovalMode","toggleButton","globalEditEnabled","_globalEditMode","toggleGlobalEditMode","snappable","draggable","includes","finishOnDoubleClick","templineStyle","hintlineStyle","dashArray","markerStyle","shapes","pathOptions","getShapes","Error","join","addButton","_enabled","toggleEdit","enabled","addLayer","center","radius","_radius","outer","_getLatLngOnCircle","_centerMarker","_createCenterMarker","_outerMarker","_createOuterMarker","_createHintLine","pointA","pointB","point","x","y","_resizeCircle","_syncHintLine","_syncCircleRadius","_moveCircle","setRadius","_hintline","markerA","markerB","_createMarker","icon","divIcon","className","_origLatLng","layerGroup","findLayers","_initLayer","getOptions","availableEvents","event","_fireEvent","fireEvent","_options","find","poly","k","_createMiddleMarker","_index","_onMarkerDragStart","_onMarkerDrag","_onMarkerDragEnd","_removeMarker","clickListener","leftM","rightM","_calcMiddleLatLng","middleMarker","middleIcon","setIcon","_middleMarkerNext","_middleMarkerPrev","_addMarker","newM","splice","i","leftMarkerIndex","rightMarkerIndex","m","nextMarkerIndex","prevMarkerIndex","markerLatLng","prevMarkerLatLng","nextMarkerLatLng","middleMarkerNextLatLng","middleMarkerPrevLatLng","markerEvent","edited","latlng1","latlng2","p1","p2","_add","_divideBy","_onDragEnd","_shape","toolbarButtonName","Util","setOptions","circle","zIndexOffset","_hintMarker","cursorMarker","_icon","_container","style","cursor","_placeCenterMarker","_syncHintMarker","_finishShape","toggle","fakeDragEvent","_placeCircleCenter","circleLayer","getCenter","_createVertex","polyPoints","lastPolygonPoint","equals","first","addLatLng","polylineLayer","polygonLayer","polygon","_tempSnapLayerIndex","Control","PMButton","position","_button","onAdd","container","buttonsDomNode","_makeButton","appendChild","onRemove","getText","text","getIconUrl","iconUrl","destroy","_update","toggleStatus","_applyStyleClasses","toggled","onCreate","_triggerClick","onClick","_clicked","afterClick","button","newButton","create","image","setAttribute","DomEvent","addListener","disableOtherButtons","triggerClickOnToggledButtons","disableClickPropagation","doToggle","drawMarker","drawPolygon","drawPolyline","drawCircle","editPolygon","dragPolygon","deleteLayer","buttons","_defineButtons","getButtons","_showHideButtons","btn","_addButton","name","exceptThisButton","status","deleteButton","drawPolyButton","drawMarkerButton","drawLineButton","drawCircleButton","editButton","dragButton","setPosition"],"mappings":"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","file":"../leaflet.pm.min.js","sourcesContent":["'use strict';\n\nvar DragMixin = {\n    _initDraggableLayer: function _initDraggableLayer() {\n        // temporary coord variable for delta calculation\n        this._tempDragCoord = null;\n\n        // add CSS class\n        var el = this._layer._path;\n        L.DomUtil.addClass(el, 'leaflet-pm-draggable');\n\n        this._layer.on('mousedown', this._dragMixinOnMouseDown, this);\n    },\n    _dragMixinOnMouseUp: function _dragMixinOnMouseUp() {\n        var _this = this;\n\n        var el = this._layer._path;\n\n        // re-enable map drag\n        this._layer._map.dragging.enable();\n\n        // clear up mousemove event\n        this._layer._map.off('mousemove', this._dragMixinOnMouseMove, this);\n\n        // clear up mouseup event\n        this._layer.off('mouseup', this._dragMixinOnMouseUp, this);\n\n        // if no drag happened, don't do anything\n        if (!this._dragging) {\n            return false;\n        }\n\n        // show markers again\n        this._initMarkers();\n\n        // timeout to prevent click event after drag :-/\n        // TODO: do it better as soon as leaflet has a way to do it better :-)\n        window.setTimeout(function () {\n            // set state\n            _this._dragging = false;\n            L.DomUtil.removeClass(el, 'leaflet-pm-dragging');\n\n            // fire pm:dragend event\n            _this._layer.fire('pm:dragend');\n\n            // fire edit\n            _this._fireEdit();\n        }, 10);\n\n        return true;\n    },\n    _dragMixinOnMouseMove: function _dragMixinOnMouseMove(e) {\n        var el = this._layer._path;\n\n        if (!this._dragging) {\n            // set state\n            this._dragging = true;\n            L.DomUtil.addClass(el, 'leaflet-pm-dragging');\n\n            // bring it to front to prevent drag interception\n            this._layer.bringToFront();\n\n            // disbale map drag\n            this._layer._map.dragging.disable();\n\n            // hide markers\n            this._markerGroup.clearLayers();\n\n            // fire pm:dragstart event\n            this._layer.fire('pm:dragstart');\n        }\n\n        this._onLayerDrag(e);\n    },\n    _dragMixinOnMouseDown: function _dragMixinOnMouseDown(e) {\n        // save for delta calculation\n        this._tempDragCoord = e.latlng;\n\n        this._layer.on('mouseup', this._dragMixinOnMouseUp, this);\n\n        // listen to mousemove on map (instead of polygon),\n        // otherwise fast mouse movements stop the drag\n        this._layer._map.on('mousemove', this._dragMixinOnMouseMove, this);\n    },\n    dragging: function dragging() {\n        return this._dragging;\n    },\n    _onLayerDrag: function _onLayerDrag(e) {\n        // latLng of mouse event\n        var latlng = e.latlng;\n\n        // delta coords (how far was dragged)\n        var deltaLatLng = {\n            lat: latlng.lat - this._tempDragCoord.lat,\n            lng: latlng.lng - this._tempDragCoord.lng\n        };\n\n        // create the new coordinates array\n        var coords = void 0;\n\n        if (this._layer instanceof L.Polygon) {\n            coords = this._layer._latlngs[0];\n        } else {\n            coords = this._layer._latlngs;\n        }\n\n        var newLatLngs = coords.map(function (currentLatLng) {\n            var c = {\n                lat: currentLatLng.lat + deltaLatLng.lat,\n                lng: currentLatLng.lng + deltaLatLng.lng\n            };\n            return c;\n        });\n\n        // set new coordinates and redraw\n        this._layer.setLatLngs(newLatLngs).redraw();\n\n        // save current latlng for next delta calculation\n        this._tempDragCoord = latlng;\n\n        // fire pm:dragstart event\n        this._layer.fire('pm:drag');\n    }\n};\n'use strict';\n\n// this isn't included anymore but if you want to re-enable it:\n// 1. include this mixing inside L.PM.Edit.js\n// 2. include the turf.js dependency in your project before leaflet.pm\n// 3. uncomment all code inside L.PM.Edit.Poly that has an if-check on options.preventOverlap\n// 4. pass the option preventOverlap to the enable() function on your layer\nvar OverlapMixin = {\n    _applyPossibleCoordsChanges: function _applyPossibleCoordsChanges() {\n        // after the polygon was dragged and changed it's shape because of unallowed intersecting\n        // with another polygon, this function takes the temporarily drawn polygon (during drag) and applies\n        // it's coordinates to our main polygon\n\n        if (this._tempPolygon) {\n            // get the new coordinates\n            var latlngs = this._tempPolygon.getLayers()[0].getLatLngs();\n\n            // reshape our main polygon\n            this._poly.setLatLngs(latlngs).redraw();\n\n            // initialize the markers again\n            this._initMarkers();\n        }\n    },\n    _drawTemporaryPolygon: function _drawTemporaryPolygon(geoJson) {\n        // hide our polygon\n        this._poly.setStyle({ opacity: 0, fillOpacity: 0 });\n\n        // draw a temporary polygon (happens during drag & intersection)\n        this._tempPolygon = L.geoJson(geoJson).addTo(this._poly._map).bringToBack();\n    },\n    _handleOverlap: function _handleOverlap() {\n        var mainPoly = this._poly;\n        var layers = this._layerGroup.getLayers();\n        var changed = false;\n        var resultingGeoJson = this._poly.toGeoJSON();\n\n        layers.filter(function (layer) {\n            return !Object.is(layer, mainPoly);\n        }).map(function (layer) {\n            var intersect = void 0;\n\n            // this needs to be in a try catch block because turf isn't reliable\n            // it throws self-intersection errors even if there are none\n            try {\n                intersect = turf.intersect(resultingGeoJson, layer.toGeoJSON());\n            } catch (e) {\n                console.warn('Turf Error.');\n            }\n\n            if (intersect) {\n                resultingGeoJson = turf.difference(resultingGeoJson, layer.toGeoJSON());\n\n                // if the resulting polygon is a MultiPolygon, don't handle it.\n                if (resultingGeoJson.geometry.type !== 'MultiPolygon') {\n                    changed = true;\n                }\n            }\n\n            return true;\n        });\n\n        if (this._tempPolygon) {\n            this._tempPolygon.remove();\n            delete this._tempPolygon;\n        }\n\n        if (changed) {\n            this._drawTemporaryPolygon(resultingGeoJson);\n        } else {\n            this._poly.setStyle({ opacity: 1, fillOpacity: 0.2 });\n        }\n    }\n};\n'use strict';\n\nvar SnapMixin = {\n    _initSnappableMarkers: function _initSnappableMarkers() {\n        var _this = this;\n\n        this.options.snapDistance = this.options.snapDistance || 30;\n\n        this._markers.forEach(function (marker) {\n            marker.off('drag', _this._handleSnapping, _this);\n            marker.on('drag', _this._handleSnapping, _this);\n\n            marker.off('dragend', _this._cleanupSnapping, _this);\n            marker.on('dragend', _this._cleanupSnapping, _this);\n        });\n\n        this._layer.off('pm:dragstart', this._unsnap, this);\n        this._layer.on('pm:dragstart', this._unsnap, this);\n    },\n    _unsnap: function _unsnap() {\n        // delete the last snap\n        delete this._snapLatLng;\n    },\n    _cleanupSnapping: function _cleanupSnapping() {\n        // delete it, we need to refresh this with each start of a drag because\n        // meanwhile, new layers could've been added to the map\n        delete this._snapList;\n\n        if (this.debugIndicatorLines) {\n            this.debugIndicatorLines.forEach(function (line) {\n                line.remove();\n            });\n        }\n    },\n    _handleSnapping: function _handleSnapping(e) {\n        // if snapping is disabled via holding ALT during drag, stop right here\n        if (e.originalEvent.altKey) {\n            return false;\n        }\n\n        // create a list of polygons that the marker could snap to\n        // this isn't inside a movestart/dragstart callback because middlemarkers are initialized\n        // after dragstart/movestart so it wouldn't fire for them\n        if (this._snapList === undefined) {\n            this._createSnapList(e);\n        }\n\n        // if there are no layers to snap to, stop here\n        if (this._snapList.length <= 0) {\n            return false;\n        }\n\n        var marker = e.target;\n\n        // get the closest layer, it's closest latlng, segment and the distance\n        var closestLayer = this._calcClosestLayer(marker.getLatLng(), this._snapList);\n\n        var isMarker = closestLayer.layer instanceof L.Marker || closestLayer.layer instanceof L.CircleMarker;\n\n        // find the final latlng that we want to snap to\n        var snapLatLng = void 0;\n        if (!isMarker) {\n            snapLatLng = this._checkPrioritiySnapping(closestLayer);\n        } else {\n            snapLatLng = closestLayer.latlng;\n        }\n\n        // minimal distance before marker snaps (in pixels)\n        var minDistance = this.options.snapDistance;\n\n        // event info for pm:snap and pm:unsnap\n        var eventInfo = {\n            marker: marker,\n            snapLatLng: snapLatLng,\n            segment: closestLayer.segment,\n            layer: this._layer,\n            layerInteractedWith: closestLayer.layer };\n\n        if (closestLayer.distance < minDistance) {\n            // snap the marker\n            marker.setLatLng(snapLatLng);\n\n            marker._snapped = true;\n\n            // check if the snapping position differs from the last snap\n            if (this._snapLatLng !== snapLatLng) {\n                // if yes, save it and fire the pm:snap event\n                this._snapLatLng = snapLatLng;\n                marker.fire('pm:snap', eventInfo);\n                this._layer.fire('pm:snap', eventInfo);\n            }\n        } else if (this._snapLatLng) {\n            // no more snapping\n\n            // if it was previously snapped...\n            // ...unsnap\n            this._unsnap(eventInfo);\n\n            marker._snapped = false;\n\n            // and fire unsnap event\n            eventInfo.marker.fire('pm:unsnap', eventInfo);\n            this._layer.fire('pm:unsnap', eventInfo);\n        }\n\n        return true;\n    },\n\n\n    // we got the point we want to snap to (C), but we need to check if a coord of the polygon\n    // receives priority over C as the snapping point. Let's check this here\n    _checkPrioritiySnapping: function _checkPrioritiySnapping(closestLayer) {\n        var map = this._map;\n\n        // A and B are the points of the closest segment to P (the marker position we want to snap)\n        var A = closestLayer.segment[0];\n        var B = closestLayer.segment[1];\n\n        // C is the point we would snap to on the segment.\n        // The closest point on the closest segment of the closest polygon to P. That's right.\n        var C = closestLayer.latlng;\n\n        // distances from A to C and B to C to check which one is closer to C\n        var distanceAC = this._getDistance(map, A, C);\n        var distanceBC = this._getDistance(map, B, C);\n\n        // closest latlng of A and B to C\n        var closestVertexLatLng = distanceAC < distanceBC ? A : B;\n\n        // distance between closestVertexLatLng and C\n        var shortestDistance = distanceAC < distanceBC ? distanceAC : distanceBC;\n\n        // the distance that needs to be undercut to trigger priority\n        var priorityDistance = this.options.snapDistance;\n\n        // the latlng we ultemately want to snap to\n        var snapLatlng = void 0;\n\n        // if C is closer to the closestVertexLatLng (A or B) than the snapDistance,\n        // the closestVertexLatLng has priority over C as the snapping point.\n        if (shortestDistance < priorityDistance) {\n            snapLatlng = closestVertexLatLng;\n        } else {\n            snapLatlng = C;\n        }\n\n        // return the copy of snapping point\n        return Object.assign({}, snapLatlng);\n    },\n    _createSnapList: function _createSnapList() {\n        var _this2 = this;\n\n        var layers = [];\n        var debugIndicatorLines = [];\n        var map = this._map;\n\n        // find all layers that are or inherit from Polylines... and markers that are not\n        // temporary markers of polygon-edits\n        map.eachLayer(function (layer) {\n            if (layer instanceof L.Polyline || layer instanceof L.Marker || layer instanceof L.CircleMarker) {\n                layers.push(layer);\n\n                // this is for debugging\n                var debugLine = L.polyline([], { color: 'red' });\n                debugIndicatorLines.push(debugLine);\n\n                // uncomment  this line to show helper lines for debugging\n                // debugLine.addTo(map);\n            }\n        });\n\n        // ...except myself\n        layers = layers.filter(function (layer) {\n            return _this2._layer !== layer;\n        });\n\n        // also remove everything that has no coordinates yet\n        layers = layers.filter(function (layer) {\n            return layer._latlng || layer._latlngs.length > 0;\n        });\n\n        // finally remove everything that's leaflet.pm specific temporary stuff\n        layers = layers.filter(function (layer) {\n            return !layer._pmTempLayer;\n        });\n\n        // save snaplist from layers and the other snap layers added from other classes/scripts\n        if (this._otherSnapLayers) {\n            this._snapList = layers.concat(this._otherSnapLayers);\n        } else {\n            this._snapList = layers;\n        }\n\n        this.debugIndicatorLines = debugIndicatorLines;\n    },\n    _calcClosestLayer: function _calcClosestLayer(latlng, layers) {\n        var _this3 = this;\n\n        // the closest polygon to our dragged marker latlng\n        var closestLayer = {};\n\n        // loop through the layers\n        layers.forEach(function (layer, index) {\n            // find the closest latlng, segment and the distance of this layer to the dragged marker latlng\n            var results = _this3._calcLayerDistances(latlng, layer);\n\n            // show indicator lines, it's for debugging\n            _this3.debugIndicatorLines[index].setLatLngs([latlng, results.latlng]);\n\n            // save the info if it doesn't exist or if the distance is smaller than the previous one\n            if (closestLayer.distance === undefined || results.distance < closestLayer.distance) {\n                closestLayer = results;\n                closestLayer.layer = layer;\n            }\n        });\n\n        // return the closest layer and it's data\n        // if there is no closest layer, return undefined\n        return closestLayer;\n    },\n    _calcLayerDistances: function _calcLayerDistances(latlng, layer) {\n        var _this4 = this;\n\n        var map = this._map;\n\n        // is this a polyline, marker or polygon?\n        var isPolygon = layer instanceof L.Polygon;\n        var isPolyline = !(layer instanceof L.Polygon) && layer instanceof L.Polyline;\n        var isMarker = layer instanceof L.Marker || layer instanceof L.CircleMarker;\n\n        // the point P which we want to snap (probpably the marker that is dragged)\n        var P = latlng;\n\n        var coords = void 0;\n\n        // the coords of the layer\n        if (isPolygon) {\n            // polygon\n            coords = layer.getLatLngs()[0];\n        } else if (isPolyline) {\n            // polyline\n            coords = layer.getLatLngs();\n        } else if (isMarker) {\n            // marker\n            coords = layer.getLatLng();\n\n            // return the info for the marker, no more calculations needed\n            return {\n                latlng: Object.assign({}, coords),\n                distance: this._getDistance(map, coords, P)\n            };\n        }\n\n        // the closest segment (line between two points) of the layer\n        var closestSegment = void 0;\n\n        // the shortest distance from P to closestSegment\n        var shortestDistance = void 0;\n\n        // loop through the coords of the layer\n        coords.forEach(function (coord, index) {\n            // take this coord (A)...\n            var A = coord;\n            var nextIndex = void 0;\n\n            // and the next coord (B) as points\n            if (isPolygon) {\n                nextIndex = index + 1 === coords.length ? 0 : index + 1;\n            } else {\n                nextIndex = index + 1 === coords.length ? undefined : index + 1;\n            }\n\n            var B = coords[nextIndex];\n\n            if (B) {\n                // calc the distance between P and AB-segment\n                var distance = _this4._getDistanceToSegment(map, P, A, B);\n\n                // is the distance shorter than the previous one? Save it and the segment\n                if (shortestDistance === undefined || distance < shortestDistance) {\n                    shortestDistance = distance;\n                    closestSegment = [A, B];\n                }\n            }\n\n            return true;\n        });\n\n        // now, take the closest segment (closestSegment) and calc the closest point to P on it.\n        var C = this._getClosestPointOnSegment(map, latlng, closestSegment[0], closestSegment[1]);\n\n        // return the latlng of that sucker\n        return {\n            latlng: Object.assign({}, C),\n            segment: closestSegment,\n            distance: shortestDistance\n        };\n    },\n    _getClosestPointOnSegment: function _getClosestPointOnSegment(map, latlng, latlngA, latlngB) {\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity) {\n            maxzoom = map.getZoom();\n        }\n        var P = map.project(latlng, maxzoom);\n        var A = map.project(latlngA, maxzoom);\n        var B = map.project(latlngB, maxzoom);\n        var closest = L.LineUtil.closestPointOnSegment(P, A, B);\n        return map.unproject(closest, maxzoom);\n    },\n    _getDistanceToSegment: function _getDistanceToSegment(map, latlng, latlngA, latlngB) {\n        var P = map.latLngToLayerPoint(latlng);\n        var A = map.latLngToLayerPoint(latlngA);\n        var B = map.latLngToLayerPoint(latlngB);\n        return L.LineUtil.pointToSegmentDistance(P, A, B);\n    },\n    _getDistance: function _getDistance(map, latlngA, latlngB) {\n        return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n    }\n};\n'use strict';\n\n/**\n*\n* A Leaflet Plugin For Editing Geometry Layers in Leaflet 1.0\n* by Sumit Kumar (@TweetsOfSumit)\n* Github Repo: https://github.com/codeofsumit/leaflet.pm\n*/\n\nL.PM = L.PM || {\n    version: '0.14.0',\n    initialize: function initialize() {\n        this.addInitHooks();\n    },\n    addInitHooks: function addInitHooks() {\n        function initLayerGroup() {\n            this.pm = new L.PM.Edit.LayerGroup(this);\n        }\n\n        L.LayerGroup.addInitHook(initLayerGroup);\n\n        function initMarker() {\n            this.pm = new L.PM.Edit.Marker(this);\n        }\n\n        L.Marker.addInitHook(initMarker);\n\n        function initPolygon() {\n            this.pm = new L.PM.Edit.Poly(this);\n        }\n\n        L.Polygon.addInitHook(initPolygon);\n\n        function initPolyline() {\n            this.pm = new L.PM.Edit.Line(this);\n        }\n\n        L.Polyline.addInitHook(initPolyline);\n\n        function initCircle() {\n            this.pm = new L.PM.Edit.Circle(this);\n        }\n\n        L.Circle.addInitHook(initCircle);\n\n        function initMap() {\n            this.pm = new L.PM.Map(this);\n        }\n\n        L.Map.addInitHook(initMap);\n    }\n};\n\n// initialize leaflet.pm\nL.PM.initialize();\n'use strict';\n\nL.PM.Map = L.Class.extend({\n    initialize: function initialize(map) {\n        this.map = map;\n        this.Draw = new L.PM.Draw(map);\n        this.Toolbar = new L.PM.Toolbar(map);\n    },\n    addControls: function addControls(options) {\n        this.Toolbar.addControls(options);\n    },\n    removeControls: function removeControls() {\n        this.Toolbar.removeControls();\n    },\n    toggleControls: function toggleControls() {\n        this.Toolbar.toggleControls();\n    },\n    controlsVisible: function controlsVisible() {\n        return this.Toolbar.isVisible;\n    },\n    enableDraw: function enableDraw() {\n        var shape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Poly';\n        var options = arguments[1];\n\n        this.Draw.enable(shape, options);\n    },\n    disableDraw: function disableDraw() {\n        var shape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Poly';\n\n        this.Draw.disable(shape);\n    },\n    setPathOptions: function setPathOptions(options) {\n        this.Draw.setPathOptions(options);\n    },\n    removeLayer: function removeLayer(e) {\n        var layer = e.target;\n        if (!layer._layers && !layer.pm.dragging()) {\n            e.target.remove();\n        }\n    },\n    toggleGlobalRemovalMode: function toggleGlobalRemovalMode() {\n        var _this = this;\n\n        // toggle global edit mode\n        if (this.globalRemovalEnabled()) {\n            this._globalRemovalMode = false;\n            this.map.eachLayer(function (layer) {\n                layer.off('click', _this.removeLayer);\n            });\n        } else {\n            this._globalRemovalMode = true;\n            this.map.eachLayer(function (layer) {\n                layer.on('click', _this.removeLayer);\n            });\n        }\n\n        // toogle the button in the toolbar\n        this.Toolbar.toggleButton('deleteLayer', this._globalRemovalMode);\n    },\n    globalRemovalEnabled: function globalRemovalEnabled() {\n        return this._globalRemovalMode;\n    },\n    globalEditEnabled: function globalEditEnabled() {\n        return this._globalEditMode;\n    },\n    toggleGlobalEditMode: function toggleGlobalEditMode() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { snappable: true, draggable: true };\n\n        // find all layers that are or inherit from Polylines...\n        var layers = [];\n        this.map.eachLayer(function (layer) {\n            if (layer instanceof L.Polyline || layer instanceof L.Marker || layer instanceof L.Circle) {\n                layers.push(layer);\n            }\n        });\n\n        // filter out layers that don't have the leaflet.pm instance\n        layers = layers.filter(function (layer) {\n            return !!layer.pm;\n        });\n\n        // filter out everything that's leaflet.pm specific temporary stuff\n        layers = layers.filter(function (layer) {\n            return !layer._pmTempLayer;\n        });\n\n        if (this.globalEditEnabled()) {\n            // disable\n\n            this._globalEditMode = false;\n\n            layers.forEach(function (layer) {\n                layer.pm.disable();\n            });\n        } else {\n            // enable\n\n            this._globalEditMode = true;\n\n            layers.forEach(function (layer) {\n                layer.pm.enable(options);\n            });\n        }\n\n        // toggle the button in the toolbar\n        this.Toolbar.toggleButton('editPolygon', this._globalEditMode);\n    }\n});\n'use strict';\n\nL.PM.Draw = L.Class.extend({\n    includes: [SnapMixin],\n    options: {\n        snappable: true,\n        snapDistance: 20,\n        finishOnDoubleClick: false,\n        templineStyle: {\n            color: 'red'\n        },\n        hintlineStyle: {\n            color: 'red',\n            dashArray: [5, 5]\n        },\n        markerStyle: {\n            draggable: true\n        }\n    },\n    initialize: function initialize(map) {\n        var _this = this;\n\n        // save the map\n        this._map = map;\n\n        // define all possible shapes that can be drawn\n        this.shapes = ['Poly', 'Line', 'Marker', 'Circle'];\n\n        // initiate drawing class for our shapes\n        this.shapes.forEach(function (shape) {\n            _this[shape] = new L.PM.Draw[shape](_this._map);\n        });\n    },\n    setPathOptions: function setPathOptions(options) {\n        this.options.pathOptions = options;\n    },\n    getShapes: function getShapes() {\n        // if somebody wants to know what shapes are available\n        return this.shapes;\n    },\n    enable: function enable(shape, options) {\n        if (!shape) {\n            throw new Error('Error: Please pass a shape as a parameter. Possible shapes are: ' + this.getShapes().join(','));\n        }\n\n        // disable drawing for all shapes\n        this.disable();\n\n        // enable draw for a shape\n        this[shape].enable(options);\n    },\n    disable: function disable() {\n        var _this2 = this;\n\n        // there can only be one drawing mode active at a time on a map\n        // so it doesn't matter which one should be disabled.\n        // just disable all of them\n        this.shapes.forEach(function (shape) {\n            _this2[shape].disable();\n        });\n    },\n    addControls: function addControls() {\n        var _this3 = this;\n\n        // add control buttons for our shapes\n        this.shapes.forEach(function (shape) {\n            _this3[shape].addButton();\n        });\n    }\n});\n\"use strict\";\n\nL.PM.Edit = L.Class.extend({\n    includes: [DragMixin, SnapMixin]\n});\n'use strict';\n\nL.PM.Edit.Circle = L.PM.Edit.extend({\n    initialize: function initialize(layer) {\n        this._layer = layer;\n        this._enabled = false;\n    },\n    toggleEdit: function toggleEdit(options) {\n        if (!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    enable: function enable() {\n        var _this = this;\n\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        this.options = options;\n\n        this._map = this._layer._map;\n\n        if (!this.enabled()) {\n            // if it was already enabled, disable first\n            // we don't block enabling again because new options might be passed\n            this.disable();\n        }\n\n        // change state\n        this._enabled = true;\n\n        // // init markers\n        this._initMarkers();\n\n        // if polygon gets removed from map, disable edit mode\n        this._layer.on('remove', function (e) {\n            _this.disable(e.target);\n        });\n    },\n    disable: function disable() {\n        var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._layer;\n\n        // if it's not enabled, it doesn't need to be disabled\n        if (!this.enabled()) {\n            return false;\n        }\n\n        // prevent disabling if layer is being dragged\n        if (layer.pm._dragging) {\n            return false;\n        }\n        layer.pm._enabled = false;\n        layer.pm._layerGroup.clearLayers();\n\n        // clean up draggable\n        layer.off('mousedown');\n        layer.off('mouseup');\n\n        // remove draggable class\n        var el = layer._path;\n        L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n\n        return true;\n    },\n    _initMarkers: function _initMarkers() {\n        var map = this._map;\n\n        // cleanup old ones first\n        if (this._layerGroup) {\n            this._layerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._layerGroup = new L.LayerGroup();\n        map.addLayer(this._layerGroup);\n\n        // create marker for each coordinate\n        var center = this._layer.getLatLng();\n        var radius = this._layer._radius;\n\n        var outer = this._getLatLngOnCircle(center, radius);\n\n        this._centerMarker = this._createCenterMarker(center);\n        this._outerMarker = this._createOuterMarker(outer);\n        this._markers = [this._centerMarker, this._outerMarker];\n        this._createHintLine(this._centerMarker, this._outerMarker);\n\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n    _getLatLngOnCircle: function _getLatLngOnCircle(center, radius) {\n        var pointA = this._map.project(center);\n        var pointB = L.point(pointA.x + radius, pointA.y);\n\n        return this._map.unproject(pointB);\n    },\n    _resizeCircle: function _resizeCircle() {\n        this._syncHintLine();\n        this._syncCircleRadius();\n    },\n    _moveCircle: function _moveCircle(e) {\n        var center = e.latlng;\n        this._layer.setLatLng(center);\n\n        var radius = this._layer._radius;\n\n        var outer = this._getLatLngOnCircle(center, radius);\n        this._outerMarker.setLatLng(outer);\n        this._syncHintLine();\n    },\n    _syncCircleRadius: function _syncCircleRadius() {\n        var A = this._centerMarker.getLatLng();\n        var B = this._outerMarker.getLatLng();\n\n        var distance = A.distanceTo(B);\n\n        this._layer.setRadius(distance);\n    },\n    _syncHintLine: function _syncHintLine() {\n        var A = this._centerMarker.getLatLng();\n        var B = this._outerMarker.getLatLng();\n\n        // set coords for hintline from marker to last vertex of drawin polyline\n        this._hintline.setLatLngs([A, B]);\n    },\n    _createHintLine: function _createHintLine(markerA, markerB) {\n        var A = markerA.getLatLng();\n        var B = markerB.getLatLng();\n        this._hintline = L.polyline([A, B], this.options.hintlineStyle);\n        this._hintline._pmTempLayer = true;\n        this._layerGroup.addLayer(this._hintline);\n    },\n    _createCenterMarker: function _createCenterMarker(latlng) {\n        var marker = this._createMarker(latlng);\n\n        // marker.on('dragstart', this._onMarkerDragStart, this);\n        marker.on('move', this._moveCircle, this);\n        // marker.on('dragend', this._onMarkerDragEnd, this);\n        // marker.on('contextmenu', this._removeMarker, this);\n\n        return marker;\n    },\n    _createOuterMarker: function _createOuterMarker(latlng) {\n        var marker = this._createMarker(latlng);\n\n        // marker.on('dragstart', this._onMarkerDragStart, this);\n        marker.on('move', this._resizeCircle, this);\n        // marker.on('dragend', this._onMarkerDragEnd, this);\n        // marker.on('contextmenu', this._removeMarker, this);\n\n        return marker;\n    },\n    _createMarker: function _createMarker(latlng) {\n        var marker = new L.Marker(latlng, {\n            draggable: true,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        marker._origLatLng = latlng;\n        marker._pmTempLayer = true;\n\n        this._layerGroup.addLayer(marker);\n\n        return marker;\n    }\n});\n'use strict';\n\n// LayerGroup doesn't inherit from L.PM.Edit because it's just calling L.PM.Edit.Poly\n// (which inherits from L.PM.Edit) for each layer,\n// so it's not really a parent class\nL.PM.Edit.LayerGroup = L.Class.extend({\n    initialize: function initialize(layerGroup) {\n        var _this = this;\n\n        this._layerGroup = layerGroup;\n        this._layers = this.findLayers();\n\n        // init all layers of the group\n        this._layers.forEach(function (layer) {\n            return _this._initLayer(layer);\n        });\n\n        // if a new layer is added to the group, reinitialize\n        // This only works for FeatureGroups, not LayerGroups\n        // https://github.com/Leaflet/Leaflet/issues/4861\n        this._layerGroup.on('layeradd', function (e) {\n            _this._layers = _this.findLayers();\n\n            // init the newly added layer\n            if (e.layer.pm) {\n                _this._initLayer(e.layer);\n            }\n\n            // if editing was already enabled for this group, enable it again\n            // so the new layers are enabled\n            if (e.target.pm.enabled()) {\n                _this.enable(_this.getOptions());\n            }\n        });\n    },\n    findLayers: function findLayers() {\n        // get all layers of the layer group\n        var layers = this._layerGroup.getLayers();\n\n        // filter out layers that don't have leaflet.pm\n        layers = layers.filter(function (layer) {\n            return !!layer.pm;\n        });\n\n        // return them\n        return layers;\n    },\n    _initLayer: function _initLayer(layer) {\n        var _this2 = this;\n\n        // available events\n        var availableEvents = ['pm:edit', 'pm:remove', 'pm:dragstart', 'pm:drag', 'pm:dragend', 'pm:snap', 'pm:unsnap', 'pm:raiseMarkers', 'pm:markerdragend', 'pm:markerdragstart'];\n\n        // listen to the events of the layers in this group\n        availableEvents.forEach(function (event) {\n            layer.on(event, _this2._fireEvent, _this2);\n        });\n\n        // add reference for the group to each layer inside said group\n        layer.pm._layerGroup = this._layerGroup;\n    },\n    _fireEvent: function _fireEvent(e) {\n        this._layerGroup.fireEvent(e.type, e);\n    },\n    toggleEdit: function toggleEdit(options) {\n        this._options = options;\n        this._layers.forEach(function (layer) {\n            layer.pm.toggleEdit(options);\n        });\n    },\n    enable: function enable(options) {\n        this._options = options;\n        this._layers.forEach(function (layer) {\n            layer.pm.enable(options);\n        });\n    },\n    disable: function disable() {\n        this._layers.forEach(function (layer) {\n            layer.pm.disable();\n        });\n    },\n    enabled: function enabled() {\n        var enabled = this._layers.find(function (layer) {\n            return layer.pm.enabled();\n        });\n        return !!enabled;\n    },\n    dragging: function dragging() {\n        var dragging = this._layers.find(function (layer) {\n            return layer.pm.dragging();\n        });\n        return !!dragging;\n    },\n    getOptions: function getOptions() {\n        return this._options;\n    }\n});\n'use strict';\n\nL.PM.Edit.Line = L.PM.Edit.extend({\n    initialize: function initialize(layer) {\n        this._layer = layer;\n        this._enabled = false;\n    },\n    toggleEdit: function toggleEdit(options) {\n        if (!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n    enable: function enable() {\n        var _this = this;\n\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        this.options = options;\n\n        this._map = this._layer._map;\n\n        // cancel when map isn't available, this happens when the polygon is removed before this fires\n        if (!this._map) {\n            return;\n        }\n\n        if (!this.enabled()) {\n            // if it was already enabled, disable first\n            // we don't block enabling again because new options might be passed\n            this.disable();\n        }\n\n        // change state\n        this._enabled = true;\n\n        // init markers\n        this._initMarkers();\n\n        // if polygon gets removed from map, disable edit mode\n        this._layer.on('remove', function (e) {\n            _this.disable(e.target);\n        });\n\n        if (this.options.draggable) {\n            this._initDraggableLayer();\n        }\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    disable: function disable() {\n        var poly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._layer;\n\n        // if it's not enabled, it doesn't need to be disabled\n        if (!this.enabled()) {\n            return false;\n        }\n\n        // prevent disabling if polygon is being dragged\n        if (poly.pm._dragging) {\n            return false;\n        }\n        poly.pm._enabled = false;\n        poly.pm._markerGroup.clearLayers();\n\n        // clean up draggable\n        poly.off('mousedown');\n        poly.off('mouseup');\n\n        // remove draggable class\n        var el = poly._path;\n        L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n\n        return true;\n    },\n    _initMarkers: function _initMarkers() {\n        var map = this._map;\n\n        // cleanup old ones first\n        if (this._markerGroup) {\n            this._markerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._markerGroup = new L.LayerGroup();\n        map.addLayer(this._markerGroup);\n\n        // create marker for each coordinate\n        var coords = this._layer._latlngs;\n\n        // the marker array, it includes only the markers that're associated with the coordinates\n        this._markers = coords.map(this._createMarker, this);\n\n        // create small markers in the middle of the regular markers\n        for (var k = 0; k < coords.length - 1; k += 1) {\n            var nextIndex = k + 1;\n            this._createMiddleMarker(this._markers[k], this._markers[nextIndex]);\n        }\n\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n\n    // creates initial markers for coordinates\n    _createMarker: function _createMarker(latlng, index) {\n        var marker = new L.Marker(latlng, {\n            draggable: true,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        marker._origLatLng = latlng;\n        marker._index = index;\n        marker._pmTempLayer = true;\n\n        marker.on('dragstart', this._onMarkerDragStart, this);\n        marker.on('move', this._onMarkerDrag, this);\n        marker.on('dragend', this._onMarkerDragEnd, this);\n        marker.on('contextmenu', this._removeMarker, this);\n        if (this.options.clickListener) {\n            marker.on('mouseup', this.options.clickListener, this);\n        }\n\n        this._markerGroup.addLayer(marker);\n\n        return marker;\n    },\n\n\n    // creates the middle markes between coordinates\n    _createMiddleMarker: function _createMiddleMarker(leftM, rightM) {\n        var _this2 = this;\n\n        var latlng = this._calcMiddleLatLng(leftM.getLatLng(), rightM.getLatLng());\n\n        var middleMarker = this._createMarker(latlng);\n        var middleIcon = L.divIcon({ className: 'marker-icon marker-icon-middle' });\n        middleMarker.setIcon(middleIcon);\n\n        // save reference to this middle markers on the neighboor regular markers\n        leftM._middleMarkerNext = middleMarker;\n        rightM._middleMarkerPrev = middleMarker;\n\n        middleMarker.on('click', function () {\n            // TODO: move the next two lines inside _addMarker() as soon as\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            // is fixed\n            var icon = L.divIcon({ className: 'marker-icon' });\n            middleMarker.setIcon(icon);\n\n            _this2._addMarker(middleMarker, leftM, rightM);\n        });\n        middleMarker.on('movestart', function () {\n            // TODO: This is a workaround. Remove the moveend listener and\n            // callback as soon as this is fixed:\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            middleMarker.on('moveend', function () {\n                var icon = L.divIcon({ className: 'marker-icon' });\n                middleMarker.setIcon(icon);\n\n                middleMarker.off('moveend');\n            });\n\n            _this2._addMarker(middleMarker, leftM, rightM);\n        });\n    },\n\n\n    // adds a new marker from a middlemarker\n    _addMarker: function _addMarker(newM, leftM, rightM) {\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        var latlng = newM.getLatLng();\n        var coords = this._layer._latlngs;\n        var index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array & update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        this._markers.map(function (marker, i) {\n            marker._index = i;\n            return true;\n        });\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n    _removeMarker: function _removeMarker(e) {\n        var marker = e.target;\n        var coords = this._layer._latlngs;\n        var index = marker._index;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if (index === undefined) {\n            return;\n        }\n\n        // remove polygon coordinate from this marker\n        coords.splice(index, 1);\n\n        // if the poly has no coordinates left, remove the layer\n        // else, redraw it\n        if (coords.length < 1) {\n            this._layer.remove();\n        } else {\n            this._layer.redraw();\n        }\n\n        // remove the marker and the middlemarkers next to it from the map\n        if (marker._middleMarkerPrev) {\n            this._markerGroup.removeLayer(marker._middleMarkerPrev);\n        }\n        if (marker._middleMarkerNext) {\n            this._markerGroup.removeLayer(marker._middleMarkerNext);\n        }\n\n        this._markerGroup.removeLayer(marker);\n\n        // find neighbor marker-indexes\n        var leftMarkerIndex = index - 1 < 0 ? undefined : index - 1;\n        var rightMarkerIndex = index + 1 >= this._markers.length ? undefined : index + 1;\n\n        // don't create middlemarkers if there is only one marker left\n        // or if the middlemarker would be between the first and last coordinate of a polyline\n        if (rightMarkerIndex && leftMarkerIndex && rightMarkerIndex !== leftMarkerIndex) {\n            var leftM = this._markers[leftMarkerIndex];\n            var rightM = this._markers[rightMarkerIndex];\n            this._createMiddleMarker(leftM, rightM);\n        }\n\n        // remove the marker from the markers array & update indexes\n        this._markers.splice(index, 1);\n        this._markers.map(function (m, i) {\n            m._index = i;\n            return true;\n        });\n\n        // fire edit event\n        this._fireEdit();\n    },\n    _onMarkerDrag: function _onMarkerDrag(e) {\n        // dragged marker\n        var marker = e.target;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if (marker._index === undefined) {\n            return;\n        }\n\n        // the dragged markers neighbors\n        var nextMarkerIndex = marker._index + 1 >= this._markers.length ? 0 : marker._index + 1;\n        var prevMarkerIndex = marker._index - 1 < 0 ? this._markers.length - 1 : marker._index - 1;\n\n        // update marker coordinates which will update polygon coordinates\n        L.extend(marker._origLatLng, marker._latlng);\n        this._layer.redraw();\n\n        // update middle markers on the left and right\n        // be aware that \"next\" and \"prev\" might be interchanged, depending on the geojson array\n        var markerLatLng = marker.getLatLng();\n        var prevMarkerLatLng = this._markers[prevMarkerIndex].getLatLng();\n        var nextMarkerLatLng = this._markers[nextMarkerIndex].getLatLng();\n\n        if (marker._middleMarkerNext) {\n            var middleMarkerNextLatLng = this._calcMiddleLatLng(markerLatLng, nextMarkerLatLng);\n            marker._middleMarkerNext.setLatLng(middleMarkerNextLatLng);\n        }\n\n        if (marker._middleMarkerPrev) {\n            var middleMarkerPrevLatLng = this._calcMiddleLatLng(markerLatLng, prevMarkerLatLng);\n            marker._middleMarkerPrev.setLatLng(middleMarkerPrevLatLng);\n        }\n    },\n    _onMarkerDragEnd: function _onMarkerDragEnd(e) {\n        this._layer.fire('pm:markerdragend', {\n            markerEvent: e\n        });\n\n        // fire edit event\n        this._fireEdit();\n    },\n    _onMarkerDragStart: function _onMarkerDragStart(e) {\n        this._layer.fire('pm:markerdragstart', {\n            markerEvent: e\n        });\n    },\n    _fireEdit: function _fireEdit() {\n        // fire edit event\n        this._layer.edited = true;\n        this._layer.fire('pm:edit');\n    },\n    _calcMiddleLatLng: function _calcMiddleLatLng(latlng1, latlng2) {\n        // calculate the middle coordinates between two markers\n        // TODO: put this into a utils.js or something\n\n        var map = this._map;\n        var p1 = map.project(latlng1);\n        var p2 = map.project(latlng2);\n\n        var latlng = map.unproject(p1._add(p2)._divideBy(2));\n\n        return latlng;\n    }\n});\n'use strict';\n\nL.PM.Edit.Marker = L.PM.Edit.extend({\n    initialize: function initialize(layer) {\n        // layer is a marker in this case :-)\n        this._layer = layer;\n        this._enabled = false;\n\n        // register dragend event e.g. to fire pm:edit\n        this._layer.on('dragend', this._onDragEnd, this);\n    },\n    toggleEdit: function toggleEdit(options) {\n        if (!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n    enable: function enable() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n            draggable: true,\n            snappable: true\n        };\n\n        this.options = options;\n\n        this._map = this._layer._map;\n\n        if (this.enabled()) {\n            return;\n        }\n        this._enabled = true;\n\n        // enable removal for the marker\n        this._layer.on('contextmenu', this._removeMarker, this);\n\n        // enable dragging and removal for the marker\n        if (this.options.snappable) {\n            this._layer.dragging.enable();\n        }\n\n        // enable snapping\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    disable: function disable() {\n        this._enabled = false;\n\n        // disable dragging and removal for the marker\n        if (this.options.snappable) {\n            this._layer.dragging.disable();\n        }\n        // this._layer.dragging.disable();\n        this._layer.off('contextmenu', this._removeMarker, this);\n    },\n    _removeMarker: function _removeMarker(e) {\n        var marker = e.target;\n        marker.remove();\n        marker.fire('pm:remove');\n    },\n    _onDragEnd: function _onDragEnd(e) {\n        var marker = e.target;\n\n        // fire the pm:edit event and pass shape and marker\n        marker.fire('pm:edit');\n    },\n\n\n    // overwrite initSnappableMarkers from Snapping.js Mixin\n    _initSnappableMarkers: function _initSnappableMarkers() {\n        var marker = this._layer;\n\n        this.options.snapDistance = this.options.snapDistance || 30;\n\n        marker.off('drag', this._handleSnapping, this);\n        marker.on('drag', this._handleSnapping, this);\n\n        marker.off('dragend', this._cleanupSnapping, this);\n        marker.on('dragend', this._cleanupSnapping, this);\n\n        marker.off('pm:dragstart', this._unsnap, this);\n        marker.on('pm:dragstart', this._unsnap, this);\n    }\n});\n'use strict';\n\nL.PM.Edit.Poly = L.PM.Edit.Line.extend({\n    _initMarkers: function _initMarkers() {\n        var map = this._map;\n\n        // cleanup old ones first\n        if (this._markerGroup) {\n            this._markerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._markerGroup = new L.LayerGroup();\n        map.addLayer(this._markerGroup);\n\n        // create marker for each coordinate\n        var coords = this._layer._latlngs[0];\n\n        // the marker array, it includes only the markers that're associated with the coordinates\n        this._markers = coords.map(this._createMarker, this);\n\n        // create small markers in the middle of the regular markers\n        for (var k = 0; k < coords.length; k += 1) {\n            var nextIndex = k + 1 >= coords.length ? 0 : k + 1;\n            this._createMiddleMarker(this._markers[k], this._markers[nextIndex]);\n        }\n\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n\n    // adds a new marker from a middlemarker\n    _addMarker: function _addMarker(newM, leftM, rightM) {\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        var latlng = newM.getLatLng();\n        var coords = this._layer._latlngs[0];\n        var index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array & update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        this._markers.map(function (marker, i) {\n            marker._index = i;\n            return true;\n        });\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n    _removeMarker: function _removeMarker(e) {\n        var marker = e.target;\n        var coords = this._layer._latlngs[0];\n        var index = marker._index;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if (index === undefined) {\n            return;\n        }\n\n        // don't remove a marker if a polygon has only 3 coordinates.\n        if (coords.length <= 3) {\n            return;\n        }\n\n        // remove polygon coordinate from this marker\n        coords.splice(index, 1);\n\n        // if the poly has no coordinates left, remove the layer\n        // else, redraw it\n        if (coords.length < 1) {\n            this._layer.remove();\n        } else {\n            this._layer.redraw();\n        }\n\n        // remove the marker and the middlemarkers next to it from the map\n        this._markerGroup.removeLayer(marker._middleMarkerPrev);\n        this._markerGroup.removeLayer(marker._middleMarkerNext);\n        this._markerGroup.removeLayer(marker);\n\n        // find neighbor marker-indexes\n        var leftMarkerIndex = index - 1 < 0 ? this._markers.length - 1 : index - 1;\n        var rightMarkerIndex = index + 1 >= this._markers.length ? 0 : index + 1;\n\n        // don't create middlemarkers if there is only one marker left\n        if (rightMarkerIndex !== leftMarkerIndex) {\n            var leftM = this._markers[leftMarkerIndex];\n            var rightM = this._markers[rightMarkerIndex];\n            this._createMiddleMarker(leftM, rightM);\n        }\n\n        // remove the marker from the markers array & update indexes\n        this._markers.splice(index, 1);\n        this._markers.map(function (m, i) {\n            m._index = i;\n            return true;\n        });\n\n        // fire edit event\n        this._fireEdit();\n    }\n});\n'use strict';\n\nL.PM.Draw.Circle = L.PM.Draw.extend({\n    initialize: function initialize(map) {\n        this._map = map;\n        this._shape = 'Circle';\n        this.toolbarButtonName = 'drawCircle';\n    },\n    enable: function enable(options) {\n        // TODO: Think about if these options could be passed globally for all\n        // instances of L.PM.Draw. So a dev could set drawing style one time as some kind of config\n        L.Util.setOptions(this, options);\n\n        this.options.radius = 0;\n\n        // enable draw mode\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the circle we want to draw\n        this._layer = L.circle([0, 0], this.options.templineStyle);\n        this._layer._pmTempLayer = true;\n        this._layerGroup.addLayer(this._layer);\n\n        // this is the marker in the center of the circle\n        this._centerMarker = L.marker([0, 0], {\n            icon: L.divIcon({ className: 'marker-icon' }),\n            draggable: true,\n            zIndexOffset: 100\n        });\n        this._centerMarker._pmTempLayer = true;\n        this._layerGroup.addLayer(this._centerMarker);\n\n        // this is the hintmarker on the mouse cursor\n        this._hintMarker = L.marker([0, 0], {\n            icon: L.divIcon({ className: 'marker-icon cursor-marker' })\n        });\n        this._hintMarker._pmTempLayer = true;\n        this._layerGroup.addLayer(this._hintMarker);\n\n        // show the hintmarker if the option is set\n        if (this.options.cursorMarker) {\n            L.DomUtil.addClass(this._hintMarker._icon, 'visible');\n        }\n\n        // this is the hintline from the hint marker to the center marker\n        this._hintline = L.polyline([], this.options.hintlineStyle);\n        this._hintline._pmTempLayer = true;\n        this._layerGroup.addLayer(this._hintline);\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._placeCenterMarker, this);\n\n        // sync hint marker with mouse cursor\n        this._map.on('mousemove', this._syncHintMarker, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n\n        // an array used in the snapping mixin.\n        // TODO: think about moving this somewhere else?\n        this._otherSnapLayers = [];\n    },\n    disable: function disable() {\n        // disable drawing mode\n\n        // cancel, if drawing mode isn't event enabled\n        if (!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._finishShape, this);\n        this._map.off('click', this._placeCenterMarker, this);\n        this._map.off('mousemove', this._syncHintMarker, this);\n\n        // remove helping layers\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n\n        // cleanup snapping\n        if (this.options.snappable) {\n            this._cleanupSnapping();\n        }\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    toggle: function toggle(options) {\n        if (this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    _syncHintLine: function _syncHintLine() {\n        var latlng = this._centerMarker.getLatLng();\n\n        // set coords for hintline from marker to last vertex of drawin polyline\n        this._hintline.setLatLngs([latlng, this._hintMarker.getLatLng()]);\n    },\n    _syncCircleRadius: function _syncCircleRadius() {\n        var A = this._centerMarker.getLatLng();\n        var B = this._hintMarker.getLatLng();\n\n        var distance = A.distanceTo(B);\n\n        this._layer.setRadius(distance);\n    },\n    _syncHintMarker: function _syncHintMarker(e) {\n        // move the cursor marker\n        this._hintMarker.setLatLng(e.latlng);\n\n        // if snapping is enabled, do it\n        if (this.options.snappable) {\n            var fakeDragEvent = e;\n            fakeDragEvent.target = this._hintMarker;\n            this._handleSnapping(fakeDragEvent);\n        }\n    },\n    _placeCenterMarker: function _placeCenterMarker(e) {\n        // assign the coordinate of the click to the hintMarker, that's necessary for\n        // mobile where the marker can't follow a cursor\n        if (!this._hintMarker._snapped) {\n            this._hintMarker.setLatLng(e.latlng);\n        }\n\n        // get coordinate for new vertex by hintMarker (cursor marker)\n        var latlng = this._hintMarker.getLatLng();\n\n        this._centerMarker.setLatLng(latlng);\n\n        this._map.off('click', this._placeCenterMarker, this);\n        this._map.on('click', this._finishShape, this);\n\n        this._placeCircleCenter();\n    },\n    _placeCircleCenter: function _placeCircleCenter() {\n        var latlng = this._centerMarker.getLatLng();\n\n        if (latlng) {\n            this._layer.setLatLng(latlng);\n\n            // sync the hintline with hint marker\n            this._hintMarker.on('move', this._syncHintLine, this);\n            this._hintMarker.on('move', this._syncCircleRadius, this);\n        }\n    },\n    _finishShape: function _finishShape() {\n        // calc the radius\n        var center = this._centerMarker.getLatLng();\n        var cursor = this._hintMarker.getLatLng();\n        var radius = center.distanceTo(cursor);\n\n        // create the final circle layer\n        var circleLayer = L.circle(center, { radius: radius }).addTo(this._map);\n\n        // disable drawing\n        this.disable();\n\n        // fire the pm:create event and pass shape and layer\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: circleLayer\n        });\n    },\n    _createMarker: function _createMarker(latlng) {\n        // create the new marker\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n        marker._pmTempLayer = true;\n\n        // add it to the map\n        this._layerGroup.addLayer(marker);\n\n        return marker;\n    }\n});\n'use strict';\n\nL.PM.Draw.Line = L.PM.Draw.extend({\n    initialize: function initialize(map) {\n        this._map = map;\n        this._shape = 'Line';\n        this.toolbarButtonName = 'drawPolyline';\n    },\n    enable: function enable(options) {\n        // TODO: Think about if these options could be passed globally for all\n        // instances of L.PM.Draw. So a dev could set drawing style one time as some kind of config\n        L.Util.setOptions(this, options);\n\n        // enable draw mode\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the polyLine that'll make up the polygon\n        this._layer = L.polyline([], this.options.templineStyle);\n        this._layer._pmTempLayer = true;\n        this._layerGroup.addLayer(this._layer);\n\n        // this is the hintline from the mouse cursor to the last marker\n        this._hintline = L.polyline([], this.options.hintlineStyle);\n        this._hintline._pmTempLayer = true;\n        this._layerGroup.addLayer(this._hintline);\n\n        // this is the hintmarker on the mouse cursor\n        this._hintMarker = L.marker(this._map.getCenter(), {\n            icon: L.divIcon({ className: 'marker-icon cursor-marker' })\n        });\n        this._hintMarker._pmTempLayer = true;\n        this._layerGroup.addLayer(this._hintMarker);\n\n        // show the hintmarker if the option is set\n        if (this.options.cursorMarker) {\n            L.DomUtil.addClass(this._hintMarker._icon, 'visible');\n        }\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._createVertex, this);\n\n        // finish on double click\n        if (this.options.finishOnDoubleClick) {\n            this._map.on('dblclick', this._finishShape, this);\n        }\n\n        // sync hint marker with mouse cursor\n        this._map.on('mousemove', this._syncHintMarker, this);\n\n        // sync the hintline with hint marker\n        this._hintMarker.on('move', this._syncHintLine, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n\n        // an array used in the snapping mixin.\n        // TODO: think about moving this somewhere else?\n        this._otherSnapLayers = [];\n    },\n    disable: function disable() {\n        // disable draw mode\n\n        // cancel, if drawing mode isn't even enabled\n        if (!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._createVertex, this);\n        this._map.off('mousemove', this._syncHintMarker, this);\n        this._map.off('dblclick', this._finishShape, this);\n\n        // remove layer\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n\n        // cleanup snapping\n        if (this.options.snappable) {\n            this._cleanupSnapping();\n        }\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    toggle: function toggle(options) {\n        if (this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    _syncHintLine: function _syncHintLine() {\n        var polyPoints = this._layer.getLatLngs();\n\n        if (polyPoints.length > 0) {\n            var lastPolygonPoint = polyPoints[polyPoints.length - 1];\n\n            // set coords for hintline from marker to last vertex of drawin polyline\n            this._hintline.setLatLngs([lastPolygonPoint, this._hintMarker.getLatLng()]);\n        }\n    },\n    _syncHintMarker: function _syncHintMarker(e) {\n        // move the cursor marker\n        this._hintMarker.setLatLng(e.latlng);\n\n        // if snapping is enabled, do it\n        if (this.options.snappable) {\n            var fakeDragEvent = e;\n            fakeDragEvent.target = this._hintMarker;\n            this._handleSnapping(fakeDragEvent);\n        }\n    },\n    _createVertex: function _createVertex(e) {\n        // assign the coordinate of the click to the hintMarker, that's necessary for\n        // mobile where the marker can't follow a cursor\n        if (!this._hintMarker._snapped) {\n            this._hintMarker.setLatLng(e.latlng);\n        }\n\n        // get coordinate for new vertex by hintMarker (cursor marker)\n        var latlng = this._hintMarker.getLatLng();\n\n        // check if the first and this vertex have the same latlng\n        if (latlng.equals(this._layer.getLatLngs()[0])) {\n            // yes? finish the polygon\n            this._finishShape();\n\n            // \"why?\", you ask? Because this happens when we snap the last vertex to the first one\n            // and then click without hitting the last marker. Click happens on the map\n            // in 99% of cases it's because the user wants to finish the polygon. So...\n            return;\n        }\n\n        // is this the first point?\n        var first = this._layer.getLatLngs().length === 0;\n\n        this._layer.addLatLng(latlng);\n        this._createMarker(latlng, first);\n\n        this._hintline.setLatLngs([latlng, latlng]);\n    },\n    _finishShape: function _finishShape() {\n        // get coordinates, create the leaflet shape and add it to the map\n        var coords = this._layer.getLatLngs();\n        var polylineLayer = L.polyline(coords, this.options.pathOptions).addTo(this._map);\n\n        // disable drawing\n        this.disable();\n\n        // fire the pm:create event and pass shape and layer\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polylineLayer\n        });\n\n        if (this.options.snappable) {\n            this._cleanupSnapping();\n        }\n    },\n    _createMarker: function _createMarker(latlng) {\n        // create the new marker\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n        marker._pmTempLayer = true;\n\n        // add it to the map\n        this._layerGroup.addLayer(marker);\n\n        // a click on any marker finishes this shape\n        marker.on('click', this._finishShape, this);\n\n        return marker;\n    }\n});\n'use strict';\n\nL.PM.Draw.Marker = L.PM.Draw.extend({\n    initialize: function initialize(map) {\n        this._map = map;\n        this._shape = 'Marker';\n        this.toolbarButtonName = 'drawMarker';\n    },\n    enable: function enable(options) {\n        // TODO: Think about if these options could be passed globally for all\n        // instances of L.PM.Draw. So a dev could set drawing style one time as some kind of config\n        L.Util.setOptions(this, options);\n\n        // change enabled state\n        this._enabled = true;\n\n        // create a marker on click on the map\n        this._map.on('click', this._createMarker, this);\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n\n        // this is the hintmarker on the mouse cursor\n        this._hintMarker = L.marker([0, 0]);\n        this._hintMarker._pmTempLayer = true;\n        this._hintMarker.addTo(this._map);\n\n        // this is just to keep the snappable mixin happy\n        this._layer = this._hintMarker;\n\n        // sync hint marker with mouse cursor\n        this._map.on('mousemove', this._syncHintMarker, this);\n\n        // enable edit mode for existing markers\n        this._map.eachLayer(function (layer) {\n            if (layer instanceof L.Marker) {\n                layer.pm.enable();\n            }\n        });\n    },\n    disable: function disable() {\n        // cancel, if drawing mode isn't even enabled\n        if (!this._enabled) {\n            return;\n        }\n\n        // undbind click event, don't create a marker on click anymore\n        this._map.off('click', this._createMarker, this);\n\n        // remove hint marker\n        this._hintMarker.remove();\n\n        // remove event listener to sync hint marker\n        this._map.off('mousemove', this._syncHintMarker, this);\n\n        // disable dragging and removing for all markers\n        this._map.eachLayer(function (layer) {\n            if (layer instanceof L.Marker && !layer._pmTempLayer) {\n                layer.pm.disable();\n            }\n        });\n\n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n\n        // change enabled state\n        this._enabled = false;\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    toggle: function toggle(options) {\n        if (this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    _createMarker: function _createMarker(e) {\n        if (!e.latlng) {\n            return;\n        }\n\n        // assign the coordinate of the click to the hintMarker, that's necessary for\n        // mobile where the marker can't follow a cursor\n        if (!this._hintMarker._snapped) {\n            this._hintMarker.setLatLng(e.latlng);\n        }\n\n        // get coordinate for new vertex by hintMarker (cursor marker)\n        var latlng = this._hintMarker.getLatLng();\n\n        // create marker\n        var marker = new L.Marker(latlng, this.options.markerStyle);\n\n        // add marker to the map\n        marker.addTo(this._map);\n\n        // enable editing for the marker\n        marker.pm.enable();\n\n        // fire the pm:create event and pass shape and marker\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            marker: marker, // DEPRECATED\n            layer: marker\n        });\n\n        this._cleanupSnapping();\n    },\n    _syncHintMarker: function _syncHintMarker(e) {\n        // move the cursor marker\n        this._hintMarker.setLatLng(e.latlng);\n\n        // if snapping is enabled, do it\n        if (this.options.snappable) {\n            var fakeDragEvent = e;\n            fakeDragEvent.target = this._hintMarker;\n            this._handleSnapping(fakeDragEvent);\n        }\n    }\n});\n'use strict';\n\nL.PM.Draw.Poly = L.PM.Draw.Line.extend({\n    initialize: function initialize(map) {\n        this._map = map;\n        this._shape = 'Poly';\n        this.toolbarButtonName = 'drawPolygon';\n    },\n    _finishShape: function _finishShape() {\n        // get coordinates, create the leaflet shape and add it to the map\n        var coords = this._layer.getLatLngs();\n        var polygonLayer = L.polygon(coords, this.options.pathOptions).addTo(this._map);\n\n        // disable drawing\n        this.disable();\n\n        // fire the pm:create event and pass shape and layer\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polygonLayer\n        });\n\n        // clean up snapping states\n        this._cleanupSnapping();\n\n        // remove the first vertex from \"other snapping layers\"\n        this._otherSnapLayers.splice(this._tempSnapLayerIndex, 1);\n        delete this._tempSnapLayerIndex;\n    },\n    _createMarker: function _createMarker(latlng, first) {\n        // create the new marker\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        // mark this marker as temporary\n        marker._pmTempLayer = true;\n\n        // add it to the map\n        this._layerGroup.addLayer(marker);\n\n        // if the first marker gets clicked again, finish this shape\n        if (first) {\n            marker.on('click', this._finishShape, this);\n\n            // add the first vertex to \"other snapping layers\" so the polygon is easier to finish\n            this._tempSnapLayerIndex = this._otherSnapLayers.push(marker) - 1;\n\n            if (this.options.snappable) {\n                this._cleanupSnapping();\n            }\n        }\n    }\n});\n'use strict';\n\nL.Control.PMButton = L.Control.extend({\n    options: {\n        position: 'topleft'\n    },\n    // TODO: clean up variable names like _button should be _options and that domNodeVariable stuff\n    initialize: function initialize(options) {\n        this._button = L.Util.setOptions(this, options);\n    },\n    onAdd: function onAdd(map) {\n        this._map = map;\n\n        this._container = this._map.pm.Toolbar.container;\n        this.buttonsDomNode = this._makeButton(this._button);\n        this._container.appendChild(this.buttonsDomNode);\n\n        return this._container;\n    },\n    onRemove: function onRemove() {\n        this.buttonsDomNode.remove();\n\n        return this._container;\n    },\n    getText: function getText() {\n        return this._button.text;\n    },\n    getIconUrl: function getIconUrl() {\n        return this._button.iconUrl;\n    },\n    destroy: function destroy() {\n        this._button = {};\n        this._update();\n    },\n    toggle: function toggle(e) {\n        if (typeof e === 'boolean') {\n            this._button.toggleStatus = e;\n        } else {\n            this._button.toggleStatus = !this._button.toggleStatus;\n        }\n        this._applyStyleClasses();\n\n        return this._button.toggleStatus;\n    },\n    toggled: function toggled() {\n        return this._button.toggleStatus;\n    },\n    onCreate: function onCreate() {\n        this.toggle(false);\n    },\n    _triggerClick: function _triggerClick(e) {\n        this._button.onClick(e);\n        this._clicked(e);\n        this._button.afterClick(e);\n    },\n    _makeButton: function _makeButton(button) {\n        var _this = this;\n\n        var newButton = L.DomUtil.create('a', 'leaflet-buttons-control-button', this._container);\n        if (button.toggleStatus) {\n            L.DomUtil.addClass(newButton, 'active');\n        }\n\n        var image = L.DomUtil.create('div', 'control-icon', newButton);\n        if (button.iconUrl) {\n            image.setAttribute('src', button.iconUrl);\n        }\n        if (button.className) {\n            L.DomUtil.addClass(image, button.className);\n        }\n        // before the actual click, trigger a click on currently toggled buttons to\n        // untoggle them and their functionality\n        L.DomEvent.addListener(newButton, 'click', function () {\n            if (_this._button.disableOtherButtons) {\n                _this._map.pm.Toolbar.triggerClickOnToggledButtons(_this);\n            }\n        });\n        L.DomEvent.addListener(newButton, 'click', this._triggerClick, this);\n\n        L.DomEvent.disableClickPropagation(newButton);\n        return newButton;\n    },\n    _applyStyleClasses: function _applyStyleClasses() {\n        if (!this._container) {\n            return;\n        }\n\n        if (!this._button.toggleStatus) {\n            L.DomUtil.removeClass(this.buttonsDomNode, 'active');\n        } else {\n            L.DomUtil.addClass(this.buttonsDomNode, 'active');\n        }\n    },\n    _clicked: function _clicked() {\n        if (this._button.doToggle) {\n            this.toggle();\n        }\n        return;\n    }\n});\n'use strict';\n\n/**\n* The Icons used in this Toolbar are CC-BY Glyphicons - http://glyphicons.com/\n*/\n\nL.PM.Toolbar = L.Class.extend({\n    options: {\n        drawMarker: true,\n        drawPolygon: true,\n        drawPolyline: true,\n        drawCircle: true,\n        editPolygon: true,\n        dragPolygon: false,\n        deleteLayer: true,\n        position: 'topleft'\n    },\n    initialize: function initialize(map) {\n        this.map = map;\n\n        this.buttons = {};\n        this.isVisible = false;\n        this.container = L.DomUtil.create('div', 'leaflet-pm-toolbar leaflet-bar leaflet-control');\n        this._defineButtons();\n    },\n    getButtons: function getButtons() {\n        return this.buttons;\n    },\n    addControls: function addControls() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options;\n\n        // adds all buttons to the map specified inside options\n\n        // first set the options\n        L.Util.setOptions(this, options);\n\n        // now show the specified buttons\n        this._showHideButtons();\n        this.isVisible = true;\n    },\n    removeControls: function removeControls() {\n        // grab all buttons to loop through\n        var buttons = this.getButtons();\n\n        // remove all buttons\n        for (var btn in buttons) {\n            buttons[btn].remove();\n        }\n\n        this.isVisible = false;\n    },\n    toggleControls: function toggleControls() {\n        if (this.isVisible) {\n            this.removeControls();\n        } else {\n            this.addControls();\n        }\n    },\n    _addButton: function _addButton(name, button) {\n        this.buttons[name] = button;\n        this.options[name] = this.options[name] || false;\n\n        return this.buttons[name];\n    },\n    triggerClickOnToggledButtons: function triggerClickOnToggledButtons(exceptThisButton) {\n        // this function is used when - e.g. drawing mode is enabled and a possible\n        // other active mode (like removal tool) is already active.\n        // we can't have two active modes because of possible event conflicts\n        // so, we trigger a click on all currently active (toggled) buttons\n\n        for (var name in this.buttons) {\n            if (this.buttons[name] !== exceptThisButton && this.buttons[name].toggled()) {\n                this.buttons[name]._triggerClick();\n            }\n        }\n    },\n    toggleButton: function toggleButton(name, status) {\n        // does not fire the events/functionality of the button\n        // this just changes the state and is used if a functionality (like Draw)\n        // is enabled manually via script\n\n        // as some mode got enabled, we still have to trigger the click on the other buttons\n        // to disable their mode\n        this.triggerClickOnToggledButtons(this.buttons[name]);\n\n        // now toggle the state of the button\n        return this.buttons[name].toggle(status);\n    },\n    _defineButtons: function _defineButtons() {\n        var _this = this;\n\n        // some buttons are still in their respective classes, like L.PM.Draw.Poly\n        var deleteButton = {\n            className: 'icon-delete',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {\n                _this.map.pm.toggleGlobalRemovalMode();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position\n        };\n\n        var drawPolyButton = {\n            className: 'icon-polygon',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {\n                // toggle drawing mode\n                _this.map.pm.Draw.Poly.toggle();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position\n        };\n\n        var drawMarkerButton = {\n            className: 'icon-marker',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {\n                // toggle drawing mode\n                _this.map.pm.Draw.Marker.toggle();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position\n        };\n\n        var drawLineButton = {\n            className: 'icon-polyline',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {\n                // toggle drawing mode\n                _this.map.pm.Draw.Line.toggle();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position\n        };\n\n        var drawCircleButton = {\n            className: 'icon-circle',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {\n                // toggle drawing mode\n                _this.map.pm.Draw.Circle.toggle();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position\n        };\n\n        var editButton = {\n            className: 'icon-edit',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {\n                _this.map.pm.toggleGlobalEditMode({\n                    snappable: true,\n                    draggable: true\n                });\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position\n        };\n\n        var dragButton = {\n            className: 'icon-drag',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {},\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position\n        };\n\n        this._addButton('drawMarker', new L.Control.PMButton(drawMarkerButton));\n        this._addButton('drawPolygon', new L.Control.PMButton(drawPolyButton));\n        this._addButton('drawPolyline', new L.Control.PMButton(drawLineButton));\n        this._addButton('drawCircle', new L.Control.PMButton(drawCircleButton));\n        // TODO: rename editPolygon to editMode\n        this._addButton('editPolygon', new L.Control.PMButton(editButton));\n        this._addButton('dragPolygon', new L.Control.PMButton(dragButton));\n        // TODO: rename deleteLayer to removalMode\n        this._addButton('deleteLayer', new L.Control.PMButton(deleteButton));\n    },\n    _showHideButtons: function _showHideButtons() {\n        // remove all buttons, that's because the Toolbar can be added again with\n        // different options so it's basically a reset and add again\n        this.removeControls();\n\n        var buttons = this.getButtons();\n        for (var btn in buttons) {\n            if (this.options[btn]) {\n                // if options say the button should be visible, add it to the map\n                buttons[btn].setPosition(this.options.position);\n                buttons[btn].addTo(this.map);\n            }\n        }\n    }\n});","const DragMixin = {\n    _initDraggableLayer() {\n        // temporary coord variable for delta calculation\n        this._tempDragCoord = null;\n\n        // add CSS class\n        const el = this._layer._path;\n        L.DomUtil.addClass(el, 'leaflet-pm-draggable');\n\n        this._layer.on('mousedown', this._dragMixinOnMouseDown, this);\n    },\n    _dragMixinOnMouseUp() {\n        const el = this._layer._path;\n\n        // re-enable map drag\n        this._layer._map.dragging.enable();\n\n        // clear up mousemove event\n        this._layer._map.off('mousemove', this._dragMixinOnMouseMove, this);\n\n        // clear up mouseup event\n        this._layer.off('mouseup', this._dragMixinOnMouseUp, this);\n\n        // if no drag happened, don't do anything\n        if(!this._dragging) {\n            return false;\n        }\n\n        // show markers again\n        this._initMarkers();\n\n        // timeout to prevent click event after drag :-/\n        // TODO: do it better as soon as leaflet has a way to do it better :-)\n        window.setTimeout(() => {\n            // set state\n            this._dragging = false;\n            L.DomUtil.removeClass(el, 'leaflet-pm-dragging');\n\n            // fire pm:dragend event\n            this._layer.fire('pm:dragend');\n\n            // fire edit\n            this._fireEdit();\n        }, 10);\n\n        return true;\n    },\n    _dragMixinOnMouseMove(e) {\n        const el = this._layer._path;\n\n        if(!this._dragging) {\n            // set state\n            this._dragging = true;\n            L.DomUtil.addClass(el, 'leaflet-pm-dragging');\n\n            // bring it to front to prevent drag interception\n            this._layer.bringToFront();\n\n            // disbale map drag\n            this._layer._map.dragging.disable();\n\n            // hide markers\n            this._markerGroup.clearLayers();\n\n            // fire pm:dragstart event\n            this._layer.fire('pm:dragstart');\n        }\n\n        this._onLayerDrag(e);\n    },\n    _dragMixinOnMouseDown(e) {\n        // save for delta calculation\n        this._tempDragCoord = e.latlng;\n\n        this._layer.on('mouseup', this._dragMixinOnMouseUp, this);\n\n        // listen to mousemove on map (instead of polygon),\n        // otherwise fast mouse movements stop the drag\n        this._layer._map.on('mousemove', this._dragMixinOnMouseMove, this);\n    },\n    dragging() {\n        return this._dragging;\n    },\n\n    _onLayerDrag(e) {\n        // latLng of mouse event\n        const latlng = e.latlng;\n\n        // delta coords (how far was dragged)\n        const deltaLatLng = {\n            lat: latlng.lat - this._tempDragCoord.lat,\n            lng: latlng.lng - this._tempDragCoord.lng,\n        };\n\n        // create the new coordinates array\n        let coords;\n\n        if(this._layer instanceof L.Polygon) {\n            coords = this._layer._latlngs[0];\n        } else {\n            coords = this._layer._latlngs;\n        }\n\n        const newLatLngs = coords.map((currentLatLng) => {\n            const c = {\n                lat: currentLatLng.lat + deltaLatLng.lat,\n                lng: currentLatLng.lng + deltaLatLng.lng,\n            };\n            return c;\n        });\n\n        // set new coordinates and redraw\n        this._layer.setLatLngs(newLatLngs).redraw();\n\n        // save current latlng for next delta calculation\n        this._tempDragCoord = latlng;\n\n        // fire pm:dragstart event\n        this._layer.fire('pm:drag');\n    },\n};\n","// this isn't included anymore but if you want to re-enable it:\n// 1. include this mixing inside L.PM.Edit.js\n// 2. include the turf.js dependency in your project before leaflet.pm\n// 3. uncomment all code inside L.PM.Edit.Poly that has an if-check on options.preventOverlap\n// 4. pass the option preventOverlap to the enable() function on your layer\nvar OverlapMixin = {\n\n    _applyPossibleCoordsChanges() {\n        // after the polygon was dragged and changed it's shape because of unallowed intersecting\n        // with another polygon, this function takes the temporarily drawn polygon (during drag) and applies\n        // it's coordinates to our main polygon\n\n        if(this._tempPolygon) {\n            // get the new coordinates\n            const latlngs = this._tempPolygon.getLayers()[0].getLatLngs();\n\n            // reshape our main polygon\n            this._poly.setLatLngs(latlngs).redraw();\n\n            // initialize the markers again\n            this._initMarkers();\n        }\n    },\n\n    _drawTemporaryPolygon(geoJson) {\n        // hide our polygon\n        this._poly.setStyle({ opacity: 0, fillOpacity: 0 });\n\n        // draw a temporary polygon (happens during drag & intersection)\n        this._tempPolygon = L.geoJson(geoJson).addTo(this._poly._map).bringToBack();\n    },\n\n    _handleOverlap() {\n        const mainPoly = this._poly;\n        const layers = this._layerGroup.getLayers();\n        let changed = false;\n        let resultingGeoJson = this._poly.toGeoJSON();\n\n        layers\n        .filter(layer => !Object.is(layer, mainPoly))\n        .map((layer) => {\n            let intersect;\n\n            // this needs to be in a try catch block because turf isn't reliable\n            // it throws self-intersection errors even if there are none\n            try {\n                intersect = turf.intersect(resultingGeoJson, layer.toGeoJSON());\n            } catch(e) {\n                console.warn('Turf Error.');\n            }\n\n            if(intersect) {\n                resultingGeoJson = turf.difference(resultingGeoJson, layer.toGeoJSON());\n\n                // if the resulting polygon is a MultiPolygon, don't handle it.\n                if(resultingGeoJson.geometry.type !== 'MultiPolygon') {\n                    changed = true;\n                }\n            }\n\n            return true;\n        });\n\n        if(this._tempPolygon) {\n            this._tempPolygon.remove();\n            delete this._tempPolygon;\n        }\n\n        if(changed) {\n            this._drawTemporaryPolygon(resultingGeoJson);\n        } else {\n            this._poly.setStyle({ opacity: 1, fillOpacity: 0.2 });\n        }\n    },\n};\n","const SnapMixin = {\n    _initSnappableMarkers() {\n        this.options.snapDistance = this.options.snapDistance || 30;\n\n        this._markers.forEach((marker) => {\n            marker.off('drag', this._handleSnapping, this);\n            marker.on('drag', this._handleSnapping, this);\n\n            marker.off('dragend', this._cleanupSnapping, this);\n            marker.on('dragend', this._cleanupSnapping, this);\n        });\n\n        this._layer.off('pm:dragstart', this._unsnap, this);\n        this._layer.on('pm:dragstart', this._unsnap, this);\n    },\n    _unsnap() {\n        // delete the last snap\n        delete this._snapLatLng;\n    },\n    _cleanupSnapping() {\n        // delete it, we need to refresh this with each start of a drag because\n        // meanwhile, new layers could've been added to the map\n        delete this._snapList;\n\n        if(this.debugIndicatorLines) {\n            this.debugIndicatorLines.forEach((line) => {\n                line.remove();\n            });\n        }\n    },\n    _handleSnapping(e) {\n        // if snapping is disabled via holding ALT during drag, stop right here\n        if(e.originalEvent.altKey) {\n            return false;\n        }\n\n        // create a list of polygons that the marker could snap to\n        // this isn't inside a movestart/dragstart callback because middlemarkers are initialized\n        // after dragstart/movestart so it wouldn't fire for them\n        if(this._snapList === undefined) {\n            this._createSnapList(e);\n        }\n\n        // if there are no layers to snap to, stop here\n        if(this._snapList.length <= 0) {\n            return false;\n        }\n\n        const marker = e.target;\n\n        // get the closest layer, it's closest latlng, segment and the distance\n        const closestLayer = this._calcClosestLayer(marker.getLatLng(), this._snapList);\n\n        const isMarker = closestLayer.layer instanceof L.Marker || closestLayer.layer instanceof L.CircleMarker;\n\n        // find the final latlng that we want to snap to\n        let snapLatLng;\n        if(!isMarker) {\n            snapLatLng = this._checkPrioritiySnapping(closestLayer);\n        } else {\n            snapLatLng = closestLayer.latlng;\n        }\n\n        // minimal distance before marker snaps (in pixels)\n        const minDistance = this.options.snapDistance;\n\n        // event info for pm:snap and pm:unsnap\n        const eventInfo = {\n            marker,\n            snapLatLng,\n            segment: closestLayer.segment,\n            layer: this._layer,\n            layerInteractedWith: closestLayer.layer, // for lack of a better property name\n        };\n\n        if(closestLayer.distance < minDistance) {\n            // snap the marker\n            marker.setLatLng(snapLatLng);\n\n            marker._snapped = true;\n\n            // check if the snapping position differs from the last snap\n            if(this._snapLatLng !== snapLatLng) {\n                // if yes, save it and fire the pm:snap event\n                this._snapLatLng = snapLatLng;\n                marker.fire('pm:snap', eventInfo);\n                this._layer.fire('pm:snap', eventInfo);\n            }\n        } else if(this._snapLatLng) {\n            // no more snapping\n\n            // if it was previously snapped...\n            // ...unsnap\n            this._unsnap(eventInfo);\n\n            marker._snapped = false;\n\n            // and fire unsnap event\n            eventInfo.marker.fire('pm:unsnap', eventInfo);\n            this._layer.fire('pm:unsnap', eventInfo);\n        }\n\n        return true;\n    },\n\n    // we got the point we want to snap to (C), but we need to check if a coord of the polygon\n    // receives priority over C as the snapping point. Let's check this here\n    _checkPrioritiySnapping(closestLayer) {\n        const map = this._map;\n\n        // A and B are the points of the closest segment to P (the marker position we want to snap)\n        const A = closestLayer.segment[0];\n        const B = closestLayer.segment[1];\n\n        // C is the point we would snap to on the segment.\n        // The closest point on the closest segment of the closest polygon to P. That's right.\n        const C = closestLayer.latlng;\n\n        // distances from A to C and B to C to check which one is closer to C\n        const distanceAC = this._getDistance(map, A, C);\n        const distanceBC = this._getDistance(map, B, C);\n\n        // closest latlng of A and B to C\n        const closestVertexLatLng = distanceAC < distanceBC ? A : B;\n\n        // distance between closestVertexLatLng and C\n        const shortestDistance = distanceAC < distanceBC ? distanceAC : distanceBC;\n\n        // the distance that needs to be undercut to trigger priority\n        const priorityDistance = this.options.snapDistance;\n\n        // the latlng we ultemately want to snap to\n        let snapLatlng;\n\n        // if C is closer to the closestVertexLatLng (A or B) than the snapDistance,\n        // the closestVertexLatLng has priority over C as the snapping point.\n        if(shortestDistance < priorityDistance) {\n            snapLatlng = closestVertexLatLng;\n        } else {\n            snapLatlng = C;\n        }\n\n        // return the copy of snapping point\n        return Object.assign({}, snapLatlng);\n    },\n\n    _createSnapList() {\n        let layers = [];\n        const debugIndicatorLines = [];\n        const map = this._map;\n\n        // find all layers that are or inherit from Polylines... and markers that are not\n        // temporary markers of polygon-edits\n        map.eachLayer((layer) => {\n            if(layer instanceof L.Polyline || layer instanceof L.Marker || layer instanceof L.CircleMarker) {\n                layers.push(layer);\n\n                // this is for debugging\n                const debugLine = L.polyline([], { color: 'red' });\n                debugIndicatorLines.push(debugLine);\n\n                // uncomment  this line to show helper lines for debugging\n                // debugLine.addTo(map);\n            }\n        });\n\n        // ...except myself\n        layers = layers.filter(layer => this._layer !== layer);\n\n        // also remove everything that has no coordinates yet\n        layers = layers.filter(layer => layer._latlng || layer._latlngs.length > 0);\n\n        // finally remove everything that's leaflet.pm specific temporary stuff\n        layers = layers.filter(layer => !layer._pmTempLayer);\n\n        // save snaplist from layers and the other snap layers added from other classes/scripts\n        if(this._otherSnapLayers) {\n            this._snapList = layers.concat(this._otherSnapLayers);\n        } else {\n            this._snapList = layers;\n        }\n\n        this.debugIndicatorLines = debugIndicatorLines;\n    },\n    _calcClosestLayer(latlng, layers) {\n        // the closest polygon to our dragged marker latlng\n        let closestLayer = {};\n\n        // loop through the layers\n        layers.forEach((layer, index) => {\n            // find the closest latlng, segment and the distance of this layer to the dragged marker latlng\n            const results = this._calcLayerDistances(latlng, layer);\n\n            // show indicator lines, it's for debugging\n            this.debugIndicatorLines[index].setLatLngs([latlng, results.latlng]);\n\n            // save the info if it doesn't exist or if the distance is smaller than the previous one\n            if(closestLayer.distance === undefined || results.distance < closestLayer.distance) {\n                closestLayer = results;\n                closestLayer.layer = layer;\n            }\n        });\n\n        // return the closest layer and it's data\n        // if there is no closest layer, return undefined\n        return closestLayer;\n    },\n\n    _calcLayerDistances(latlng, layer) {\n        const map = this._map;\n\n        // is this a polyline, marker or polygon?\n        const isPolygon = layer instanceof L.Polygon;\n        const isPolyline = !(layer instanceof L.Polygon) && layer instanceof L.Polyline;\n        const isMarker = layer instanceof L.Marker || layer instanceof L.CircleMarker;\n\n        // the point P which we want to snap (probpably the marker that is dragged)\n        const P = latlng;\n\n        let coords;\n\n        // the coords of the layer\n        if(isPolygon) {\n            // polygon\n            coords = layer.getLatLngs()[0];\n        } else if(isPolyline) {\n            // polyline\n            coords = layer.getLatLngs();\n        } else if(isMarker) {\n            // marker\n            coords = layer.getLatLng();\n\n            // return the info for the marker, no more calculations needed\n            return {\n                latlng: Object.assign({}, coords),\n                distance: this._getDistance(map, coords, P),\n            };\n        }\n\n        // the closest segment (line between two points) of the layer\n        let closestSegment;\n\n        // the shortest distance from P to closestSegment\n        let shortestDistance;\n\n        // loop through the coords of the layer\n        coords.forEach((coord, index) => {\n            // take this coord (A)...\n            const A = coord;\n            let nextIndex;\n\n            // and the next coord (B) as points\n            if(isPolygon) {\n                nextIndex = index + 1 === coords.length ? 0 : index + 1;\n            } else {\n                nextIndex = index + 1 === coords.length ? undefined : index + 1;\n            }\n\n            const B = coords[nextIndex];\n\n            if(B) {\n                // calc the distance between P and AB-segment\n                const distance = this._getDistanceToSegment(map, P, A, B);\n\n                // is the distance shorter than the previous one? Save it and the segment\n                if(shortestDistance === undefined || distance < shortestDistance) {\n                    shortestDistance = distance;\n                    closestSegment = [A, B];\n                }\n            }\n\n            return true;\n        });\n\n        // now, take the closest segment (closestSegment) and calc the closest point to P on it.\n        const C = this._getClosestPointOnSegment(map, latlng, closestSegment[0], closestSegment[1]);\n\n        // return the latlng of that sucker\n        return {\n            latlng: Object.assign({}, C),\n            segment: closestSegment,\n            distance: shortestDistance,\n        };\n    },\n\n    _getClosestPointOnSegment(map, latlng, latlngA, latlngB) {\n        let maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity) {\n            maxzoom = map.getZoom();\n        }\n        const P = map.project(latlng, maxzoom);\n        const A = map.project(latlngA, maxzoom);\n        const B = map.project(latlngB, maxzoom);\n        const closest = L.LineUtil.closestPointOnSegment(P, A, B);\n        return map.unproject(closest, maxzoom);\n    },\n    _getDistanceToSegment(map, latlng, latlngA, latlngB) {\n        const P = map.latLngToLayerPoint(latlng);\n        const A = map.latLngToLayerPoint(latlngA);\n        const B = map.latLngToLayerPoint(latlngB);\n        return L.LineUtil.pointToSegmentDistance(P, A, B);\n    },\n    _getDistance(map, latlngA, latlngB) {\n        return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n    },\n};\n","/**\n*\n* A Leaflet Plugin For Editing Geometry Layers in Leaflet 1.0\n* by Sumit Kumar (@TweetsOfSumit)\n* Github Repo: https://github.com/codeofsumit/leaflet.pm\n*/\n\nL.PM = L.PM || {\n    version: '0.14.0',\n    initialize() {\n        this.addInitHooks();\n    },\n    addInitHooks() {\n        function initLayerGroup() {\n            this.pm = new L.PM.Edit.LayerGroup(this);\n        }\n\n        L.LayerGroup.addInitHook(initLayerGroup);\n\n        function initMarker() {\n            this.pm = new L.PM.Edit.Marker(this);\n        }\n\n        L.Marker.addInitHook(initMarker);\n\n\n        function initPolygon() {\n            this.pm = new L.PM.Edit.Poly(this);\n        }\n\n        L.Polygon.addInitHook(initPolygon);\n\n\n        function initPolyline() {\n            this.pm = new L.PM.Edit.Line(this);\n        }\n\n        L.Polyline.addInitHook(initPolyline);\n\n\n        function initCircle() {\n            this.pm = new L.PM.Edit.Circle(this);\n        }\n\n        L.Circle.addInitHook(initCircle);\n\n\n        function initMap() {\n            this.pm = new L.PM.Map(this);\n        }\n\n        L.Map.addInitHook(initMap);\n    },\n};\n\n// initialize leaflet.pm\nL.PM.initialize();\n","L.PM.Map = L.Class.extend({\n    initialize(map) {\n        this.map = map;\n        this.Draw = new L.PM.Draw(map);\n        this.Toolbar = new L.PM.Toolbar(map);\n    },\n    addControls(options) {\n        this.Toolbar.addControls(options);\n    },\n    removeControls() {\n        this.Toolbar.removeControls();\n    },\n    toggleControls() {\n        this.Toolbar.toggleControls();\n    },\n    controlsVisible() {\n        return this.Toolbar.isVisible;\n    },\n    enableDraw(shape = 'Poly', options) {\n        this.Draw.enable(shape, options);\n    },\n    disableDraw(shape = 'Poly') {\n        this.Draw.disable(shape);\n    },\n    setPathOptions(options) {\n        this.Draw.setPathOptions(options);\n    },\n    removeLayer(e) {\n        const layer = e.target;\n        if(!layer._layers && !layer.pm.dragging()) {\n            e.target.remove();\n        }\n    },\n    toggleGlobalRemovalMode() {\n        // toggle global edit mode\n        if(this.globalRemovalEnabled()) {\n            this._globalRemovalMode = false;\n            this.map.eachLayer((layer) => {\n                layer.off('click', this.removeLayer);\n            });\n        } else {\n            this._globalRemovalMode = true;\n            this.map.eachLayer((layer) => {\n                layer.on('click', this.removeLayer);\n            });\n        }\n\n        // toogle the button in the toolbar\n        this.Toolbar.toggleButton('deleteLayer', this._globalRemovalMode);\n    },\n    globalRemovalEnabled() {\n        return this._globalRemovalMode;\n    },\n    globalEditEnabled() {\n        return this._globalEditMode;\n    },\n    toggleGlobalEditMode(options = { snappable: true, draggable: true }) {\n        // find all layers that are or inherit from Polylines...\n        let layers = [];\n        this.map.eachLayer((layer) => {\n            if(layer instanceof L.Polyline || layer instanceof L.Marker || layer instanceof L.Circle) {\n                layers.push(layer);\n            }\n        });\n\n        // filter out layers that don't have the leaflet.pm instance\n        layers = layers.filter(layer => !!layer.pm);\n\n        // filter out everything that's leaflet.pm specific temporary stuff\n        layers = layers.filter(layer => !layer._pmTempLayer);\n\n        if(this.globalEditEnabled()) {\n            // disable\n\n            this._globalEditMode = false;\n\n            layers.forEach((layer) => {\n                layer.pm.disable();\n            });\n        } else {\n            // enable\n\n            this._globalEditMode = true;\n\n            layers.forEach((layer) => {\n                layer.pm.enable(options);\n            });\n        }\n\n        // toggle the button in the toolbar\n        this.Toolbar.toggleButton('editPolygon', this._globalEditMode);\n    },\n});\n","L.PM.Draw = L.Class.extend({\n    includes: [SnapMixin],\n    options: {\n        snappable: true,\n        snapDistance: 20,\n        finishOnDoubleClick: false,\n        templineStyle: {\n            color: 'red',\n        },\n        hintlineStyle: {\n            color: 'red',\n            dashArray: [5, 5],\n        },\n        markerStyle: {\n            draggable: true,\n        },\n    },\n    initialize(map) {\n        // save the map\n        this._map = map;\n\n        // define all possible shapes that can be drawn\n        this.shapes = ['Poly', 'Line', 'Marker', 'Circle'];\n\n        // initiate drawing class for our shapes\n        this.shapes.forEach((shape) => {\n            this[shape] = new L.PM.Draw[shape](this._map);\n        });\n    },\n    setPathOptions(options) {\n        this.options.pathOptions = options;\n    },\n    getShapes() {\n        // if somebody wants to know what shapes are available\n        return this.shapes;\n    },\n    enable(shape, options) {\n        if(!shape) {\n            throw new Error(`Error: Please pass a shape as a parameter. Possible shapes are: ${this.getShapes().join(',')}`);\n        }\n\n        // disable drawing for all shapes\n        this.disable();\n\n        // enable draw for a shape\n        this[shape].enable(options);\n    },\n    disable() {\n        // there can only be one drawing mode active at a time on a map\n        // so it doesn't matter which one should be disabled.\n        // just disable all of them\n        this.shapes.forEach((shape) => {\n            this[shape].disable();\n        });\n    },\n    addControls() {\n        // add control buttons for our shapes\n        this.shapes.forEach((shape) => {\n            this[shape].addButton();\n        });\n    },\n});\n","L.PM.Edit = L.Class.extend({\n    includes: [DragMixin, SnapMixin],\n});\n","L.PM.Edit.Circle = L.PM.Edit.extend({\n    initialize(layer) {\n        this._layer = layer;\n        this._enabled = false;\n    },\n    toggleEdit(options) {\n        if(!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n    enabled() {\n        return this._enabled;\n    },\n    enable(options = {}) {\n        this.options = options;\n\n        this._map = this._layer._map;\n\n        if(!this.enabled()) {\n            // if it was already enabled, disable first\n            // we don't block enabling again because new options might be passed\n            this.disable();\n        }\n\n        // change state\n        this._enabled = true;\n\n        // // init markers\n        this._initMarkers();\n\n        // if polygon gets removed from map, disable edit mode\n        this._layer.on('remove', (e) => {\n            this.disable(e.target);\n        });\n    },\n    disable(layer = this._layer) {\n        // if it's not enabled, it doesn't need to be disabled\n        if(!this.enabled()) {\n            return false;\n        }\n\n        // prevent disabling if layer is being dragged\n        if(layer.pm._dragging) {\n            return false;\n        }\n        layer.pm._enabled = false;\n        layer.pm._layerGroup.clearLayers();\n\n        // clean up draggable\n        layer.off('mousedown');\n        layer.off('mouseup');\n\n        // remove draggable class\n        const el = layer._path;\n        L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n\n        return true;\n    },\n    _initMarkers() {\n        const map = this._map;\n\n        // cleanup old ones first\n        if(this._layerGroup) {\n            this._layerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._layerGroup = new L.LayerGroup();\n        map.addLayer(this._layerGroup);\n\n        // create marker for each coordinate\n        const center = this._layer.getLatLng();\n        const radius = this._layer._radius;\n\n        const outer = this._getLatLngOnCircle(center, radius);\n\n        this._centerMarker = this._createCenterMarker(center);\n        this._outerMarker = this._createOuterMarker(outer);\n        this._markers = [this._centerMarker, this._outerMarker];\n        this._createHintLine(this._centerMarker, this._outerMarker);\n\n        if(this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n    _getLatLngOnCircle(center, radius) {\n        const pointA = this._map.project(center);\n        const pointB = L.point(pointA.x + radius, pointA.y);\n\n        return this._map.unproject(pointB);\n    },\n    _resizeCircle() {\n        this._syncHintLine();\n        this._syncCircleRadius();\n    },\n    _moveCircle(e) {\n        const center = e.latlng;\n        this._layer.setLatLng(center);\n\n        const radius = this._layer._radius;\n\n        const outer = this._getLatLngOnCircle(center, radius);\n        this._outerMarker.setLatLng(outer);\n        this._syncHintLine();\n    },\n    _syncCircleRadius() {\n        const A = this._centerMarker.getLatLng();\n        const B = this._outerMarker.getLatLng();\n\n        const distance = A.distanceTo(B);\n\n        this._layer.setRadius(distance);\n    },\n    _syncHintLine() {\n        const A = this._centerMarker.getLatLng();\n        const B = this._outerMarker.getLatLng();\n\n        // set coords for hintline from marker to last vertex of drawin polyline\n        this._hintline.setLatLngs([A, B]);\n    },\n    _createHintLine(markerA, markerB) {\n        const A = markerA.getLatLng();\n        const B = markerB.getLatLng();\n        this._hintline = L.polyline([A, B], this.options.hintlineStyle);\n        this._hintline._pmTempLayer = true;\n        this._layerGroup.addLayer(this._hintline);\n    },\n    _createCenterMarker(latlng) {\n        const marker = this._createMarker(latlng);\n\n        // marker.on('dragstart', this._onMarkerDragStart, this);\n        marker.on('move', this._moveCircle, this);\n        // marker.on('dragend', this._onMarkerDragEnd, this);\n        // marker.on('contextmenu', this._removeMarker, this);\n\n        return marker;\n    },\n    _createOuterMarker(latlng) {\n        const marker = this._createMarker(latlng);\n\n        // marker.on('dragstart', this._onMarkerDragStart, this);\n        marker.on('move', this._resizeCircle, this);\n        // marker.on('dragend', this._onMarkerDragEnd, this);\n        // marker.on('contextmenu', this._removeMarker, this);\n\n        return marker;\n    },\n    _createMarker(latlng) {\n        const marker = new L.Marker(latlng, {\n            draggable: true,\n            icon: L.divIcon({ className: 'marker-icon' }),\n        });\n\n        marker._origLatLng = latlng;\n        marker._pmTempLayer = true;\n\n        this._layerGroup.addLayer(marker);\n\n        return marker;\n    },\n});\n","// LayerGroup doesn't inherit from L.PM.Edit because it's just calling L.PM.Edit.Poly\n// (which inherits from L.PM.Edit) for each layer,\n// so it's not really a parent class\nL.PM.Edit.LayerGroup = L.Class.extend({\n    initialize(layerGroup) {\n        this._layerGroup = layerGroup;\n        this._layers = this.findLayers();\n\n        // init all layers of the group\n        this._layers.forEach(layer => this._initLayer(layer));\n\n        // if a new layer is added to the group, reinitialize\n        // This only works for FeatureGroups, not LayerGroups\n        // https://github.com/Leaflet/Leaflet/issues/4861\n        this._layerGroup.on('layeradd', (e) => {\n            this._layers = this.findLayers();\n\n            // init the newly added layer\n            if(e.layer.pm) {\n                this._initLayer(e.layer);\n            }\n\n            // if editing was already enabled for this group, enable it again\n            // so the new layers are enabled\n            if(e.target.pm.enabled()) {\n                this.enable(this.getOptions());\n            }\n        });\n    },\n    findLayers() {\n        // get all layers of the layer group\n        let layers = this._layerGroup.getLayers();\n\n        // filter out layers that don't have leaflet.pm\n        layers = layers.filter(layer => !!layer.pm);\n\n        // return them\n        return layers;\n    },\n    _initLayer(layer) {\n        // available events\n        const availableEvents = [\n            'pm:edit',\n            'pm:remove',\n            'pm:dragstart',\n            'pm:drag',\n            'pm:dragend',\n            'pm:snap',\n            'pm:unsnap',\n            'pm:raiseMarkers',\n            'pm:markerdragend',\n            'pm:markerdragstart',\n        ];\n\n        // listen to the events of the layers in this group\n        availableEvents.forEach((event) => {\n            layer.on(event, this._fireEvent, this);\n        });\n\n        // add reference for the group to each layer inside said group\n        layer.pm._layerGroup = this._layerGroup;\n    },\n    _fireEvent(e) {\n        this._layerGroup.fireEvent(e.type, e);\n    },\n    toggleEdit(options) {\n        this._options = options;\n        this._layers.forEach((layer) => {\n            layer.pm.toggleEdit(options);\n        });\n    },\n    enable(options) {\n        this._options = options;\n        this._layers.forEach((layer) => {\n            layer.pm.enable(options);\n        });\n    },\n    disable() {\n        this._layers.forEach((layer) => {\n            layer.pm.disable();\n        });\n    },\n    enabled() {\n        const enabled = this._layers.find(layer => layer.pm.enabled());\n        return !!enabled;\n    },\n    dragging() {\n        const dragging = this._layers.find(layer => layer.pm.dragging());\n        return !!dragging;\n    },\n    getOptions() {\n        return this._options;\n    },\n});\n","L.PM.Edit.Line = L.PM.Edit.extend({\n    initialize(layer) {\n        this._layer = layer;\n        this._enabled = false;\n    },\n\n    toggleEdit(options) {\n        if(!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n\n    enable(options = {}) {\n        this.options = options;\n\n        this._map = this._layer._map;\n\n        // cancel when map isn't available, this happens when the polygon is removed before this fires\n        if(!this._map) {\n            return;\n        }\n\n        if(!this.enabled()) {\n            // if it was already enabled, disable first\n            // we don't block enabling again because new options might be passed\n            this.disable();\n        }\n\n        // change state\n        this._enabled = true;\n\n        // init markers\n        this._initMarkers();\n\n        // if polygon gets removed from map, disable edit mode\n        this._layer.on('remove', (e) => {\n            this.disable(e.target);\n        });\n\n        if(this.options.draggable) {\n            this._initDraggableLayer();\n        }\n    },\n\n    enabled() {\n        return this._enabled;\n    },\n\n    disable(poly = this._layer) {\n        // if it's not enabled, it doesn't need to be disabled\n        if(!this.enabled()) {\n            return false;\n        }\n\n        // prevent disabling if polygon is being dragged\n        if(poly.pm._dragging) {\n            return false;\n        }\n        poly.pm._enabled = false;\n        poly.pm._markerGroup.clearLayers();\n\n        // clean up draggable\n        poly.off('mousedown');\n        poly.off('mouseup');\n\n        // remove draggable class\n        const el = poly._path;\n        L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n\n        return true;\n    },\n\n    _initMarkers() {\n        const map = this._map;\n\n        // cleanup old ones first\n        if(this._markerGroup) {\n            this._markerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._markerGroup = new L.LayerGroup();\n        map.addLayer(this._markerGroup);\n\n        // create marker for each coordinate\n        const coords = this._layer._latlngs;\n\n        // the marker array, it includes only the markers that're associated with the coordinates\n        this._markers = coords.map(this._createMarker, this);\n\n        // create small markers in the middle of the regular markers\n        for(let k = 0; k < coords.length - 1; k += 1) {\n            const nextIndex = k + 1;\n            this._createMiddleMarker(\n                this._markers[k], this._markers[nextIndex]\n            );\n        }\n\n        if(this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n    // creates initial markers for coordinates\n    _createMarker(latlng, index) {\n        const marker = new L.Marker(latlng, {\n            draggable: true,\n            icon: L.divIcon({ className: 'marker-icon' }),\n        });\n\n        marker._origLatLng = latlng;\n        marker._index = index;\n        marker._pmTempLayer = true;\n\n        marker.on('dragstart', this._onMarkerDragStart, this);\n        marker.on('move', this._onMarkerDrag, this);\n        marker.on('dragend', this._onMarkerDragEnd, this);\n        marker.on('contextmenu', this._removeMarker, this);\n        if (this.options.clickListener) {\n          marker.on('mouseup', this.options.clickListener, this);\n        }\n\n        this._markerGroup.addLayer(marker);\n\n        return marker;\n    },\n\n    // creates the middle markes between coordinates\n    _createMiddleMarker(leftM, rightM) {\n        const latlng = this._calcMiddleLatLng(leftM.getLatLng(), rightM.getLatLng());\n\n        const middleMarker = this._createMarker(latlng);\n        const middleIcon = L.divIcon({ className: 'marker-icon marker-icon-middle' });\n        middleMarker.setIcon(middleIcon);\n\n        // save reference to this middle markers on the neighboor regular markers\n        leftM._middleMarkerNext = middleMarker;\n        rightM._middleMarkerPrev = middleMarker;\n\n        middleMarker.on('click', () => {\n            // TODO: move the next two lines inside _addMarker() as soon as\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            // is fixed\n            const icon = L.divIcon({ className: 'marker-icon' });\n            middleMarker.setIcon(icon);\n\n            this._addMarker(middleMarker, leftM, rightM);\n        });\n        middleMarker.on('movestart', () => {\n            // TODO: This is a workaround. Remove the moveend listener and\n            // callback as soon as this is fixed:\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            middleMarker.on('moveend', () => {\n                const icon = L.divIcon({ className: 'marker-icon' });\n                middleMarker.setIcon(icon);\n\n                middleMarker.off('moveend');\n            });\n\n            this._addMarker(middleMarker, leftM, rightM);\n        });\n    },\n\n    // adds a new marker from a middlemarker\n    _addMarker(newM, leftM, rightM) {\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        const latlng = newM.getLatLng();\n        const coords = this._layer._latlngs;\n        const index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array & update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        this._markers.map((marker, i) => {\n            marker._index = i;\n            return true;\n        });\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n\n        if(this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n    _removeMarker(e) {\n        const marker = e.target;\n        const coords = this._layer._latlngs;\n        const index = marker._index;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if(index === undefined) {\n            return;\n        }\n\n        // remove polygon coordinate from this marker\n        coords.splice(index, 1);\n\n        // if the poly has no coordinates left, remove the layer\n        // else, redraw it\n        if(coords.length < 1) {\n            this._layer.remove();\n        } else {\n            this._layer.redraw();\n        }\n\n        // remove the marker and the middlemarkers next to it from the map\n        if(marker._middleMarkerPrev) {\n            this._markerGroup.removeLayer(marker._middleMarkerPrev);\n        }\n        if(marker._middleMarkerNext) {\n            this._markerGroup.removeLayer(marker._middleMarkerNext);\n        }\n\n        this._markerGroup.removeLayer(marker);\n\n        // find neighbor marker-indexes\n        const leftMarkerIndex = index - 1 < 0 ? undefined : index - 1;\n        const rightMarkerIndex = index + 1 >= this._markers.length ? undefined : index + 1;\n\n        // don't create middlemarkers if there is only one marker left\n        // or if the middlemarker would be between the first and last coordinate of a polyline\n        if(rightMarkerIndex && leftMarkerIndex && rightMarkerIndex !== leftMarkerIndex) {\n            const leftM = this._markers[leftMarkerIndex];\n            const rightM = this._markers[rightMarkerIndex];\n            this._createMiddleMarker(leftM, rightM);\n        }\n\n        // remove the marker from the markers array & update indexes\n        this._markers.splice(index, 1);\n        this._markers.map((m, i) => {\n            m._index = i;\n            return true;\n        });\n\n        // fire edit event\n        this._fireEdit();\n    },\n\n    _onMarkerDrag(e) {\n        // dragged marker\n        const marker = e.target;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if(marker._index === undefined) {\n            return;\n        }\n\n        // the dragged markers neighbors\n        const nextMarkerIndex = marker._index + 1 >= this._markers.length ? 0 : marker._index + 1;\n        const prevMarkerIndex = marker._index - 1 < 0 ? this._markers.length - 1 : marker._index - 1;\n\n        // update marker coordinates which will update polygon coordinates\n        L.extend(marker._origLatLng, marker._latlng);\n        this._layer.redraw();\n\n        // update middle markers on the left and right\n        // be aware that \"next\" and \"prev\" might be interchanged, depending on the geojson array\n        const markerLatLng = marker.getLatLng();\n        const prevMarkerLatLng = this._markers[prevMarkerIndex].getLatLng();\n        const nextMarkerLatLng = this._markers[nextMarkerIndex].getLatLng();\n\n        if(marker._middleMarkerNext) {\n            const middleMarkerNextLatLng = this._calcMiddleLatLng(markerLatLng, nextMarkerLatLng);\n            marker._middleMarkerNext.setLatLng(middleMarkerNextLatLng);\n        }\n\n        if(marker._middleMarkerPrev) {\n            const middleMarkerPrevLatLng = this._calcMiddleLatLng(markerLatLng, prevMarkerLatLng);\n            marker._middleMarkerPrev.setLatLng(middleMarkerPrevLatLng);\n        }\n    },\n\n    _onMarkerDragEnd(e) {\n        this._layer.fire('pm:markerdragend', {\n            markerEvent: e,\n        });\n\n        // fire edit event\n        this._fireEdit();\n    },\n    _onMarkerDragStart(e) {\n        this._layer.fire('pm:markerdragstart', {\n            markerEvent: e,\n        });\n    },\n\n    _fireEdit() {\n        // fire edit event\n        this._layer.edited = true;\n        this._layer.fire('pm:edit');\n    },\n\n    _calcMiddleLatLng(latlng1, latlng2) {\n        // calculate the middle coordinates between two markers\n        // TODO: put this into a utils.js or something\n\n        const map = this._map;\n        const p1 = map.project(latlng1);\n        const p2 = map.project(latlng2);\n\n        const latlng = map.unproject(p1._add(p2)._divideBy(2));\n\n        return latlng;\n    },\n});\n","L.PM.Edit.Marker = L.PM.Edit.extend({\n    initialize(layer) {\n        // layer is a marker in this case :-)\n        this._layer = layer;\n        this._enabled = false;\n\n        // register dragend event e.g. to fire pm:edit\n        this._layer.on('dragend', this._onDragEnd, this);\n    },\n\n    toggleEdit(options) {\n        if(!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n\n    enable(options = {\n        draggable: true,\n        snappable: true,\n    }) {\n        this.options = options;\n\n        this._map = this._layer._map;\n\n        if(this.enabled()) {\n            return;\n        }\n        this._enabled = true;\n\n\n        // enable removal for the marker\n        this._layer.on('contextmenu', this._removeMarker, this);\n\n        // enable dragging and removal for the marker\n        if(this.options.snappable) {\n            this._layer.dragging.enable();\n        }\n\n        // enable snapping\n        if(this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n    enabled() {\n        return this._enabled;\n    },\n\n    disable() {\n        this._enabled = false;\n\n        // disable dragging and removal for the marker\n        if(this.options.snappable) {\n            this._layer.dragging.disable();\n        }\n        // this._layer.dragging.disable();\n        this._layer.off('contextmenu', this._removeMarker, this);\n    },\n    _removeMarker(e) {\n        const marker = e.target;\n        marker.remove();\n        marker.fire('pm:remove');\n    },\n    _onDragEnd(e) {\n        const marker = e.target;\n\n        // fire the pm:edit event and pass shape and marker\n        marker.fire('pm:edit');\n    },\n\n    // overwrite initSnappableMarkers from Snapping.js Mixin\n    _initSnappableMarkers() {\n        const marker = this._layer;\n\n        this.options.snapDistance = this.options.snapDistance || 30;\n\n        marker.off('drag', this._handleSnapping, this);\n        marker.on('drag', this._handleSnapping, this);\n\n        marker.off('dragend', this._cleanupSnapping, this);\n        marker.on('dragend', this._cleanupSnapping, this);\n\n        marker.off('pm:dragstart', this._unsnap, this);\n        marker.on('pm:dragstart', this._unsnap, this);\n    },\n});\n","L.PM.Edit.Poly = L.PM.Edit.Line.extend({\n\n    _initMarkers() {\n        const map = this._map;\n\n        // cleanup old ones first\n        if(this._markerGroup) {\n            this._markerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._markerGroup = new L.LayerGroup();\n        map.addLayer(this._markerGroup);\n\n        // create marker for each coordinate\n        const coords = this._layer._latlngs[0];\n\n        // the marker array, it includes only the markers that're associated with the coordinates\n        this._markers = coords.map(this._createMarker, this);\n\n        // create small markers in the middle of the regular markers\n        for(let k = 0; k < coords.length; k += 1) {\n            const nextIndex = k + 1 >= coords.length ? 0 : k + 1;\n            this._createMiddleMarker(\n                this._markers[k], this._markers[nextIndex]\n            );\n        }\n\n        if(this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n    // adds a new marker from a middlemarker\n    _addMarker(newM, leftM, rightM) {\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        const latlng = newM.getLatLng();\n        const coords = this._layer._latlngs[0];\n        const index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array & update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        this._markers.map((marker, i) => {\n            marker._index = i;\n            return true;\n        });\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n\n        if(this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n    _removeMarker(e) {\n        const marker = e.target;\n        const coords = this._layer._latlngs[0];\n        const index = marker._index;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if(index === undefined) {\n            return;\n        }\n\n        // don't remove a marker if a polygon has only 3 coordinates.\n        if(coords.length <= 3) {\n            return;\n        }\n\n        // remove polygon coordinate from this marker\n        coords.splice(index, 1);\n\n        // if the poly has no coordinates left, remove the layer\n        // else, redraw it\n        if(coords.length < 1) {\n            this._layer.remove();\n        } else {\n            this._layer.redraw();\n        }\n\n        // remove the marker and the middlemarkers next to it from the map\n        this._markerGroup.removeLayer(marker._middleMarkerPrev);\n        this._markerGroup.removeLayer(marker._middleMarkerNext);\n        this._markerGroup.removeLayer(marker);\n\n        // find neighbor marker-indexes\n        const leftMarkerIndex = index - 1 < 0 ? this._markers.length - 1 : index - 1;\n        const rightMarkerIndex = index + 1 >= this._markers.length ? 0 : index + 1;\n\n        // don't create middlemarkers if there is only one marker left\n        if(rightMarkerIndex !== leftMarkerIndex) {\n            const leftM = this._markers[leftMarkerIndex];\n            const rightM = this._markers[rightMarkerIndex];\n            this._createMiddleMarker(leftM, rightM);\n        }\n\n        // remove the marker from the markers array & update indexes\n        this._markers.splice(index, 1);\n        this._markers.map((m, i) => {\n            m._index = i;\n            return true;\n        });\n\n        // fire edit event\n        this._fireEdit();\n    },\n});\n","L.PM.Draw.Circle = L.PM.Draw.extend({\n    initialize(map) {\n        this._map = map;\n        this._shape = 'Circle';\n        this.toolbarButtonName = 'drawCircle';\n    },\n    enable(options) {\n        // TODO: Think about if these options could be passed globally for all\n        // instances of L.PM.Draw. So a dev could set drawing style one time as some kind of config\n        L.Util.setOptions(this, options);\n\n        this.options.radius = 0;\n\n        // enable draw mode\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the circle we want to draw\n        this._layer = L.circle([0, 0], this.options.templineStyle);\n        this._layer._pmTempLayer = true;\n        this._layerGroup.addLayer(this._layer);\n\n        // this is the marker in the center of the circle\n        this._centerMarker = L.marker([0, 0], {\n            icon: L.divIcon({ className: 'marker-icon' }),\n            draggable: true,\n            zIndexOffset: 100,\n        });\n        this._centerMarker._pmTempLayer = true;\n        this._layerGroup.addLayer(this._centerMarker);\n\n        // this is the hintmarker on the mouse cursor\n        this._hintMarker = L.marker([0, 0], {\n            icon: L.divIcon({ className: 'marker-icon cursor-marker' }),\n        });\n        this._hintMarker._pmTempLayer = true;\n        this._layerGroup.addLayer(this._hintMarker);\n\n        // show the hintmarker if the option is set\n        if(this.options.cursorMarker) {\n            L.DomUtil.addClass(this._hintMarker._icon, 'visible');\n        }\n\n        // this is the hintline from the hint marker to the center marker\n        this._hintline = L.polyline([], this.options.hintlineStyle);\n        this._hintline._pmTempLayer = true;\n        this._layerGroup.addLayer(this._hintline);\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._placeCenterMarker, this);\n\n        // sync hint marker with mouse cursor\n        this._map.on('mousemove', this._syncHintMarker, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n\n        // an array used in the snapping mixin.\n        // TODO: think about moving this somewhere else?\n        this._otherSnapLayers = [];\n    },\n    disable() {\n        // disable drawing mode\n\n        // cancel, if drawing mode isn't event enabled\n        if(!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._finishShape, this);\n        this._map.off('click', this._placeCenterMarker, this);\n        this._map.off('mousemove', this._syncHintMarker, this);\n\n        // remove helping layers\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n\n        // cleanup snapping\n        if(this.options.snappable) {\n            this._cleanupSnapping();\n        }\n    },\n    enabled() {\n        return this._enabled;\n    },\n    toggle(options) {\n        if(this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    _syncHintLine() {\n        const latlng = this._centerMarker.getLatLng();\n\n        // set coords for hintline from marker to last vertex of drawin polyline\n        this._hintline.setLatLngs([latlng, this._hintMarker.getLatLng()]);\n    },\n    _syncCircleRadius() {\n        const A = this._centerMarker.getLatLng();\n        const B = this._hintMarker.getLatLng();\n\n        const distance = A.distanceTo(B);\n\n        this._layer.setRadius(distance);\n    },\n    _syncHintMarker(e) {\n        // move the cursor marker\n        this._hintMarker.setLatLng(e.latlng);\n\n        // if snapping is enabled, do it\n        if(this.options.snappable) {\n            const fakeDragEvent = e;\n            fakeDragEvent.target = this._hintMarker;\n            this._handleSnapping(fakeDragEvent);\n        }\n    },\n    _placeCenterMarker(e) {\n        // assign the coordinate of the click to the hintMarker, that's necessary for\n        // mobile where the marker can't follow a cursor\n        if(!this._hintMarker._snapped) {\n            this._hintMarker.setLatLng(e.latlng);\n        }\n\n        // get coordinate for new vertex by hintMarker (cursor marker)\n        const latlng = this._hintMarker.getLatLng();\n\n        this._centerMarker.setLatLng(latlng);\n\n        this._map.off('click', this._placeCenterMarker, this);\n        this._map.on('click', this._finishShape, this);\n\n        this._placeCircleCenter();\n    },\n    _placeCircleCenter() {\n        const latlng = this._centerMarker.getLatLng();\n\n        if(latlng) {\n            this._layer.setLatLng(latlng);\n\n            // sync the hintline with hint marker\n            this._hintMarker.on('move', this._syncHintLine, this);\n            this._hintMarker.on('move', this._syncCircleRadius, this);\n        }\n    },\n    _finishShape() {\n        // calc the radius\n        const center = this._centerMarker.getLatLng();\n        const cursor = this._hintMarker.getLatLng();\n        const radius = center.distanceTo(cursor);\n\n        // create the final circle layer\n        const circleLayer = L.circle(center, { radius }).addTo(this._map);\n\n        // disable drawing\n        this.disable();\n\n        // fire the pm:create event and pass shape and layer\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: circleLayer,\n        });\n    },\n    _createMarker(latlng) {\n        // create the new marker\n        const marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' }),\n        });\n        marker._pmTempLayer = true;\n\n        // add it to the map\n        this._layerGroup.addLayer(marker);\n\n        return marker;\n    },\n});\n","L.PM.Draw.Line = L.PM.Draw.extend({\n    initialize(map) {\n        this._map = map;\n        this._shape = 'Line';\n        this.toolbarButtonName = 'drawPolyline';\n    },\n    enable(options) {\n        // TODO: Think about if these options could be passed globally for all\n        // instances of L.PM.Draw. So a dev could set drawing style one time as some kind of config\n        L.Util.setOptions(this, options);\n\n        // enable draw mode\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the polyLine that'll make up the polygon\n        this._layer = L.polyline([], this.options.templineStyle);\n        this._layer._pmTempLayer = true;\n        this._layerGroup.addLayer(this._layer);\n\n        // this is the hintline from the mouse cursor to the last marker\n        this._hintline = L.polyline([], this.options.hintlineStyle);\n        this._hintline._pmTempLayer = true;\n        this._layerGroup.addLayer(this._hintline);\n\n        // this is the hintmarker on the mouse cursor\n        this._hintMarker = L.marker(this._map.getCenter(), {\n            icon: L.divIcon({ className: 'marker-icon cursor-marker' }),\n        });\n        this._hintMarker._pmTempLayer = true;\n        this._layerGroup.addLayer(this._hintMarker);\n\n        // show the hintmarker if the option is set\n        if(this.options.cursorMarker) {\n            L.DomUtil.addClass(this._hintMarker._icon, 'visible');\n        }\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._createVertex, this);\n\n        // finish on double click\n        if(this.options.finishOnDoubleClick) {\n            this._map.on('dblclick', this._finishShape, this);\n        }\n\n        // sync hint marker with mouse cursor\n        this._map.on('mousemove', this._syncHintMarker, this);\n\n        // sync the hintline with hint marker\n        this._hintMarker.on('move', this._syncHintLine, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n\n        // an array used in the snapping mixin.\n        // TODO: think about moving this somewhere else?\n        this._otherSnapLayers = [];\n    },\n    disable() {\n        // disable draw mode\n\n        // cancel, if drawing mode isn't even enabled\n        if(!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._createVertex, this);\n        this._map.off('mousemove', this._syncHintMarker, this);\n        this._map.off('dblclick', this._finishShape, this);\n\n        // remove layer\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n\n        // cleanup snapping\n        if(this.options.snappable) {\n            this._cleanupSnapping();\n        }\n    },\n    enabled() {\n        return this._enabled;\n    },\n    toggle(options) {\n        if(this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    _syncHintLine() {\n        const polyPoints = this._layer.getLatLngs();\n\n        if(polyPoints.length > 0) {\n            const lastPolygonPoint = polyPoints[polyPoints.length - 1];\n\n            // set coords for hintline from marker to last vertex of drawin polyline\n            this._hintline.setLatLngs([lastPolygonPoint, this._hintMarker.getLatLng()]);\n        }\n    },\n    _syncHintMarker(e) {\n        // move the cursor marker\n        this._hintMarker.setLatLng(e.latlng);\n\n        // if snapping is enabled, do it\n        if(this.options.snappable) {\n            const fakeDragEvent = e;\n            fakeDragEvent.target = this._hintMarker;\n            this._handleSnapping(fakeDragEvent);\n        }\n    },\n    _createVertex(e) {\n        // assign the coordinate of the click to the hintMarker, that's necessary for\n        // mobile where the marker can't follow a cursor\n        if(!this._hintMarker._snapped) {\n            this._hintMarker.setLatLng(e.latlng);\n        }\n\n        // get coordinate for new vertex by hintMarker (cursor marker)\n        const latlng = this._hintMarker.getLatLng();\n\n        // check if the first and this vertex have the same latlng\n        if(latlng.equals(this._layer.getLatLngs()[0])) {\n            // yes? finish the polygon\n            this._finishShape();\n\n            // \"why?\", you ask? Because this happens when we snap the last vertex to the first one\n            // and then click without hitting the last marker. Click happens on the map\n            // in 99% of cases it's because the user wants to finish the polygon. So...\n            return;\n        }\n\n        // is this the first point?\n        const first = this._layer.getLatLngs().length === 0;\n\n        this._layer.addLatLng(latlng);\n        this._createMarker(latlng, first);\n\n\n        this._hintline.setLatLngs([latlng, latlng]);\n    },\n    _finishShape() {\n        // get coordinates, create the leaflet shape and add it to the map\n        const coords = this._layer.getLatLngs();\n        const polylineLayer = L.polyline(coords, this.options.pathOptions).addTo(this._map);\n\n        // disable drawing\n        this.disable();\n\n        // fire the pm:create event and pass shape and layer\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polylineLayer,\n        });\n\n        if(this.options.snappable) {\n            this._cleanupSnapping();\n        }\n    },\n    _createMarker(latlng) {\n        // create the new marker\n        const marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' }),\n        });\n        marker._pmTempLayer = true;\n\n        // add it to the map\n        this._layerGroup.addLayer(marker);\n\n        // a click on any marker finishes this shape\n        marker.on('click', this._finishShape, this);\n\n        return marker;\n    },\n});\n","L.PM.Draw.Marker = L.PM.Draw.extend({\n    initialize(map) {\n        this._map = map;\n        this._shape = 'Marker';\n        this.toolbarButtonName = 'drawMarker';\n    },\n    enable(options) {\n        // TODO: Think about if these options could be passed globally for all\n        // instances of L.PM.Draw. So a dev could set drawing style one time as some kind of config\n        L.Util.setOptions(this, options);\n\n        // change enabled state\n        this._enabled = true;\n\n        // create a marker on click on the map\n        this._map.on('click', this._createMarker, this);\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n\n        // this is the hintmarker on the mouse cursor\n        this._hintMarker = L.marker([0, 0]);\n        this._hintMarker._pmTempLayer = true;\n        this._hintMarker.addTo(this._map);\n\n        // this is just to keep the snappable mixin happy\n        this._layer = this._hintMarker;\n\n        // sync hint marker with mouse cursor\n        this._map.on('mousemove', this._syncHintMarker, this);\n\n        // enable edit mode for existing markers\n        this._map.eachLayer((layer) => {\n            if(layer instanceof L.Marker) {\n                layer.pm.enable();\n            }\n        });\n    },\n    disable() {\n        // cancel, if drawing mode isn't even enabled\n        if(!this._enabled) {\n            return;\n        }\n\n        // undbind click event, don't create a marker on click anymore\n        this._map.off('click', this._createMarker, this);\n\n        // remove hint marker\n        this._hintMarker.remove();\n\n        // remove event listener to sync hint marker\n        this._map.off('mousemove', this._syncHintMarker, this);\n        \n        // disable dragging and removing for all markers\n        this._map.eachLayer((layer) => {\n            if(layer instanceof L.Marker && !layer._pmTempLayer) {\n                layer.pm.disable();\n            }\n        });\n        \n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n\n        // change enabled state\n        this._enabled = false;\n    },\n    enabled() {\n        return this._enabled;\n    },\n    toggle(options) {\n        if(this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    _createMarker(e) {\n        if(!e.latlng) {\n            return;\n        }\n\n        // assign the coordinate of the click to the hintMarker, that's necessary for\n        // mobile where the marker can't follow a cursor\n        if(!this._hintMarker._snapped) {\n            this._hintMarker.setLatLng(e.latlng);\n        }\n\n        // get coordinate for new vertex by hintMarker (cursor marker)\n        const latlng = this._hintMarker.getLatLng();\n\n        // create marker\n        const marker = new L.Marker(latlng, this.options.markerStyle);\n\n        // add marker to the map\n        marker.addTo(this._map);\n\n        // enable editing for the marker\n        marker.pm.enable();\n\n        // fire the pm:create event and pass shape and marker\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            marker,                     // DEPRECATED\n            layer: marker,\n        });\n\n        this._cleanupSnapping();\n    },\n    _syncHintMarker(e) {\n        // move the cursor marker\n        this._hintMarker.setLatLng(e.latlng);\n\n        // if snapping is enabled, do it\n        if(this.options.snappable) {\n            const fakeDragEvent = e;\n            fakeDragEvent.target = this._hintMarker;\n            this._handleSnapping(fakeDragEvent);\n        }\n    },\n});\n","L.PM.Draw.Poly = L.PM.Draw.Line.extend({\n\n    initialize(map) {\n        this._map = map;\n        this._shape = 'Poly';\n        this.toolbarButtonName = 'drawPolygon';\n    },\n    _finishShape() {\n        // get coordinates, create the leaflet shape and add it to the map\n        const coords = this._layer.getLatLngs();\n        const polygonLayer = L.polygon(coords, this.options.pathOptions).addTo(this._map);\n\n        // disable drawing\n        this.disable();\n\n        // fire the pm:create event and pass shape and layer\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polygonLayer,\n        });\n\n        // clean up snapping states\n        this._cleanupSnapping();\n\n        // remove the first vertex from \"other snapping layers\"\n        this._otherSnapLayers.splice(this._tempSnapLayerIndex, 1);\n        delete this._tempSnapLayerIndex;\n    },\n    _createMarker(latlng, first) {\n        // create the new marker\n        const marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' }),\n        });\n\n        // mark this marker as temporary\n        marker._pmTempLayer = true;\n\n        // add it to the map\n        this._layerGroup.addLayer(marker);\n\n        // if the first marker gets clicked again, finish this shape\n        if(first) {\n            marker.on('click', this._finishShape, this);\n\n            // add the first vertex to \"other snapping layers\" so the polygon is easier to finish\n            this._tempSnapLayerIndex = this._otherSnapLayers.push(marker) - 1;\n\n            if(this.options.snappable) {\n                this._cleanupSnapping();\n            }\n        }\n    },\n});\n","L.Control.PMButton = L.Control.extend({\n    options: {\n        position: 'topleft',\n    },\n    // TODO: clean up variable names like _button should be _options and that domNodeVariable stuff\n    initialize(options) {\n        this._button = L.Util.setOptions(this, options);\n    },\n\n    onAdd(map) {\n        this._map = map;\n\n        this._container = this._map.pm.Toolbar.container;\n        this.buttonsDomNode = this._makeButton(this._button);\n        this._container.appendChild(this.buttonsDomNode);\n\n        return this._container;\n    },\n\n    onRemove() {\n        this.buttonsDomNode.remove();\n\n        return this._container;\n    },\n\n    getText() {\n        return this._button.text;\n    },\n\n    getIconUrl() {\n        return this._button.iconUrl;\n    },\n\n    destroy() {\n        this._button = {};\n        this._update();\n    },\n\n    toggle(e) {\n        if(typeof e === 'boolean') {\n            this._button.toggleStatus = e;\n        } else {\n            this._button.toggleStatus = !this._button.toggleStatus;\n        }\n        this._applyStyleClasses();\n\n        return this._button.toggleStatus;\n    },\n    toggled() {\n        return this._button.toggleStatus;\n    },\n    onCreate() {\n        this.toggle(false);\n    },\n    _triggerClick(e) {\n        this._button.onClick(e);\n        this._clicked(e);\n        this._button.afterClick(e);\n    },\n    _makeButton(button) {\n        const newButton = L.DomUtil.create('a', 'leaflet-buttons-control-button', this._container);\n        if(button.toggleStatus) {\n            L.DomUtil.addClass(newButton, 'active');\n        }\n\n        const image = L.DomUtil.create('div', 'control-icon', newButton);\n        if (button.iconUrl) {\n            image.setAttribute('src', button.iconUrl);\n        }\n        if (button.className) {\n            L.DomUtil.addClass(image, button.className);\n        }\n        // before the actual click, trigger a click on currently toggled buttons to\n        // untoggle them and their functionality\n        L.DomEvent.addListener(newButton, 'click', () => {\n            if(this._button.disableOtherButtons) {\n                this._map.pm.Toolbar.triggerClickOnToggledButtons(this);\n            }\n        });\n        L.DomEvent.addListener(newButton, 'click', this._triggerClick, this);\n\n        L.DomEvent.disableClickPropagation(newButton);\n        return newButton;\n    },\n\n    _applyStyleClasses() {\n        if(!this._container) {\n            return;\n        }\n\n        if(!this._button.toggleStatus) {\n            L.DomUtil.removeClass(this.buttonsDomNode, 'active');\n        } else {\n            L.DomUtil.addClass(this.buttonsDomNode, 'active');\n        }\n    },\n\n    _clicked() {\n        if(this._button.doToggle) {\n            this.toggle();\n        }\n        return;\n    },\n\n});\n","/**\n* The Icons used in this Toolbar are CC-BY Glyphicons - http://glyphicons.com/\n*/\n\nL.PM.Toolbar = L.Class.extend({\n    options: {\n        drawMarker: true,\n        drawPolygon: true,\n        drawPolyline: true,\n        drawCircle: true,\n        editPolygon: true,\n        dragPolygon: false,\n        deleteLayer: true,\n        position: 'topleft',\n    },\n    initialize(map) {\n        this.map = map;\n\n        this.buttons = {};\n        this.isVisible = false;\n        this.container = L.DomUtil.create('div', 'leaflet-pm-toolbar leaflet-bar leaflet-control');\n        this._defineButtons();\n    },\n    getButtons() {\n        return this.buttons;\n    },\n\n    addControls(options = this.options) {\n        // adds all buttons to the map specified inside options\n\n        // first set the options\n        L.Util.setOptions(this, options);\n\n        // now show the specified buttons\n        this._showHideButtons();\n        this.isVisible = true;\n    },\n    removeControls() {\n        // grab all buttons to loop through\n        const buttons = this.getButtons();\n\n        // remove all buttons\n        for (const btn in buttons) {\n            buttons[btn].remove();\n        }\n\n        this.isVisible = false;\n    },\n    toggleControls() {\n        if (this.isVisible) {\n            this.removeControls();\n        } else {\n            this.addControls();\n        }\n    },\n    _addButton(name, button) {\n        this.buttons[name] = button;\n        this.options[name] = this.options[name] || false;\n\n        return this.buttons[name];\n    },\n    triggerClickOnToggledButtons(exceptThisButton) {\n        // this function is used when - e.g. drawing mode is enabled and a possible\n        // other active mode (like removal tool) is already active.\n        // we can't have two active modes because of possible event conflicts\n        // so, we trigger a click on all currently active (toggled) buttons\n\n        for (const name in this.buttons) {\n            if(this.buttons[name] !== exceptThisButton && this.buttons[name].toggled()) {\n                this.buttons[name]._triggerClick();\n            }\n        }\n    },\n    toggleButton(name, status) {\n        // does not fire the events/functionality of the button\n        // this just changes the state and is used if a functionality (like Draw)\n        // is enabled manually via script\n\n        // as some mode got enabled, we still have to trigger the click on the other buttons\n        // to disable their mode\n        this.triggerClickOnToggledButtons(this.buttons[name]);\n\n        // now toggle the state of the button\n        return this.buttons[name].toggle(status);\n    },\n    _defineButtons() {\n        // some buttons are still in their respective classes, like L.PM.Draw.Poly\n        const deleteButton = {\n            className: 'icon-delete',\n            onClick: () => {\n\n            },\n            afterClick: () => {\n                this.map.pm.toggleGlobalRemovalMode();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position,\n        };\n\n        const drawPolyButton = {\n            className: 'icon-polygon',\n            onClick: () => {\n\n            },\n            afterClick: () => {\n                // toggle drawing mode\n                this.map.pm.Draw.Poly.toggle();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position,\n        };\n\n        const drawMarkerButton = {\n            className: 'icon-marker',\n            onClick: () => {\n\n            },\n            afterClick: () => {\n                // toggle drawing mode\n                this.map.pm.Draw.Marker.toggle();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position,\n        };\n\n        const drawLineButton = {\n            className: 'icon-polyline',\n            onClick: () => {\n\n            },\n            afterClick: () => {\n                // toggle drawing mode\n                this.map.pm.Draw.Line.toggle();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position,\n        };\n\n        const drawCircleButton = {\n            className: 'icon-circle',\n            onClick: () => {\n\n            },\n            afterClick: () => {\n                // toggle drawing mode\n                this.map.pm.Draw.Circle.toggle();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position,\n        };\n\n        const editButton = {\n            className: 'icon-edit',\n            onClick: () => {\n            },\n            afterClick: () => {\n                this.map.pm.toggleGlobalEditMode({\n                    snappable: true,\n                    draggable: true,\n                });\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position,\n        };\n\n        const dragButton = {\n            className: 'icon-drag',\n            onClick: () => {\n            },\n            afterClick: () => {\n\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position,\n        };\n\n        this._addButton('drawMarker', new L.Control.PMButton(drawMarkerButton));\n        this._addButton('drawPolygon', new L.Control.PMButton(drawPolyButton));\n        this._addButton('drawPolyline', new L.Control.PMButton(drawLineButton));\n        this._addButton('drawCircle', new L.Control.PMButton(drawCircleButton));\n        // TODO: rename editPolygon to editMode\n        this._addButton('editPolygon', new L.Control.PMButton(editButton));\n        this._addButton('dragPolygon', new L.Control.PMButton(dragButton));\n        // TODO: rename deleteLayer to removalMode\n        this._addButton('deleteLayer', new L.Control.PMButton(deleteButton));\n    },\n\n    _showHideButtons() {\n        // remove all buttons, that's because the Toolbar can be added again with\n        // different options so it's basically a reset and add again\n        this.removeControls();\n\n        const buttons = this.getButtons();\n        for (const btn in buttons) {\n            if(this.options[btn]) {\n                // if options say the button should be visible, add it to the map\n                buttons[btn].setPosition(this.options.position);\n                buttons[btn].addTo(this.map);\n            }\n        }\n    },\n});\n"]}