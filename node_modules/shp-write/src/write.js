var types = require('./types'),
    dbf = require('dbf'),
    prj = require('./prj'),
    ext = require('./extent'),
    getFields = require('./fields'),
    ***REMOVED***ert = require('***REMOVED***ert'),
    geojson = require('./geojson'),
    pointWriter = require('./points'),
    prj = require('./prj'),
    JSZip = require('jszip');
    polyWriter = require('./poly');

var writers = {
    1: pointWriter,
    5: polyWriter,
    3: polyWriter
};

var recordHeaderLength = 8;

module.exports.write = write;
module.exports.writeGeoJson = writeGeoJson;

// Low-level writing interface
function write(rows, geometry_type, geometries, callback) {

    var TYPE = types.geometries[geometry_type],
        writer = writers[TYPE],
        shpLength = 100 + writer.shpLength(geometries),
        shxLength = 100 + writer.shxLength(geometries),
        shpBuffer = new ArrayBuffer(shpLength),
        shpView = new DataView(shpBuffer),
        shxBuffer = new ArrayBuffer(shxLength),
        shxView = new DataView(shxBuffer),
        extent = writer.extent(geometries);

    writeHeader(shpView, TYPE);
    writeHeader(shxView, TYPE);
    writeExtent(extent, shpView);
    writeExtent(extent, shxView);

    writer.write(geometries, extent,
        new DataView(shpBuffer, 100),
        new DataView(shxBuffer, 100),
        TYPE);

    shpView.setInt32(24, shpLength / 2);
    shxView.setInt32(24, (50 + geometries.length * 4));

    var dbfBuf = dbf.structure(rows);

    callback(null, {
        shp: shpView,
        shx: shxView,
        dbf: dbfBuf,
        prj: prj
    });
}

function writeGeoJson(gj, name, callback) {
    var zip = new JSZip(),
        layers = zip.folder('layers');

    [geojson.point(gj), geojson.line(gj), geojson.polygon(gj)]
        .forEach(function(l) {
        if (l.geometries.length) {
            write(
                // field definitions
                l.properties,
                // geometry type
                l.type,
                // geometries
                l.geometries,
                function(err, files) {
                    layers.file(name + '_'+ l.type + '.shp', files.shp.buffer, { binary: true });
                    layers.file(name + '_'+ l.type + '.shx', files.shx.buffer, { binary: true });
                    layers.file(name + '_'+ l.type + '.dbf', files.dbf.buffer, { binary: true });
                    layers.file(name + '_'+ l.type + '.prj', prj);
                });
        }
    });

    var content = zip.generate({compression:'STORE'});
    callback(null, content);
}

function writeHeader(view, TYPE) {
    view.setInt32(0, 9994);
    view.setInt32(28, 1000, true);
    view.setInt32(32, TYPE, true);
}

function writeExtent(extent, view) {
    view.setFloat64(36, extent.xmin, true);
    view.setFloat64(44, extent.ymin, true);
    view.setFloat64(52, extent.xmax, true);
    view.setFloat64(60, extent.ymax, true);
}
